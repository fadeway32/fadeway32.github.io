<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <!--    <meta name="referrer" content="origin">-->
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>
        
            17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码
        
    </title>
    <link rel="shortcut icon" href="#"/>

    <link type="text/css" rel="stylesheet" href="/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSerifSC.css">
    <link type="text/css" rel="stylesheet" href="/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="/font/Roboto.css">
    <link type="text/css" rel="stylesheet" href="/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="/css/base.css">
    <link type="text/css" rel="stylesheet" href="/css/code.css">

    <script type="text/javascript" src="/js/jquery-3.4.1.min.js"></script>
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
    <a id="cover"></a>
    <link type="text/css" rel="stylesheet" href="/css/post.css">
<header>
    <meta name="referrer" content="no-referrer">
</header>
<div id="header" class="header">
    <div class="vertical">
        <div class="inner">
            
                <h1 class="header-subtitle">17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2025-02-16
                        </span>
                        
                            <span id="/article/1739713342/" class="leancloud_visitors" data-flag-title="17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码">
                                <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                            </span>
                        
                        <span>
                            <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/article/1739713342/"></span>
                        </span>
                    </p>
                    
                        
                            <span class="category-color">Web</span>
                        
                    
                    
                        
                            <span class="tag-color">RocketMq</span>
                        
                    
                </div>
            
        </div>
    </div>
    
</div>
<div id="container">
    
        <!-- 文章页面 -->
        <div id="article">
            <div class="toc"></div>
            <div class="article-body">
                <h1 id="17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码"><a href="#17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码" class="headerlink" title="17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码"></a>17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码</h1><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul>
<li>1 doRebalance执行重平衡</li>
<li>2 RebalanceImpl#doRebalance执行重平衡</li>
<li>3 rebalanceByTopic根据topic执行重平衡</li>
<li>4 findConsumerIdList查找客户端id集合</li>
<li><ul>
<li>4.1 findBrokerAddrByTopic随机查找broker</li>
</ul>
</li>
<li>4.2 getConsumerIdListByGroup获取Group所有ConsumerId集合</li>
<li><ul>
<li>4.2.1 broker处理getConsumerListByGroup请求<ul>
<li>4.2.2 ConsumerManageProcessor#getConsumerListByGroup</li>
</ul>
</li>
</ul>
</li>
<li>5 allocate分配消息队列</li>
<li><ul>
<li>5.1 AllocateMessageQueueAveragely平均分配</li>
</ul>
</li>
<li>5.2 AllocateMessageQueueAveragelyByCircle环形平均分配</li>
<li>5.3AllocateMessageQueueByConfig根据配置分配</li>
<li>5.4 AllocateMessageQueueByMachineRoom机房平均分配</li>
<li></li>
<li>5.5 AllocateMachineRoomNearby机房就近分配</li>
<li>5.6 AllocateMessageQueueConsistentHash一致性哈希分配</li>
<li>6 updateProcessQueueTableInRebalance更新处理队列</li>
<li><ul>
<li>6.1 removeUnnecessaryMessageQueue移除非必要的消息队列</li>
</ul>
</li>
<li><ul>
<li>6.1.1 unlockDelay延迟解锁</li>
</ul>
</li>
<li>6.2 lock获取分布式锁</li>
<li>6.3 computePullFromWhereWithException计算offset</li>
<li><ul>
<li>6.3.1 readOffset获取offset</li>
<li><ul>
<li>6.3.1.1 fetchConsumeOffsetFromBroker从broker获取offset</li>
<li>6.3.1.2 queryConsumerOffset查询消费偏移量</li>
</ul>
</li>
</ul>
</li>
<li>6.4 dispatchPullRequest分发拉取消息请求PullRequest</li>
<li>7 messageQueueChanged更新消息队列</li>
<li>8 总结</li>
</ul>
<h2 id="1-doRebalance执行重平衡"><a href="#1-doRebalance执行重平衡" class="headerlink" title="1 doRebalance执行重平衡"></a>1 doRebalance执行重平衡</h2><ul>
<li>*负载均衡or重平衡的触发操作，最终都会执行MQClientInstance的doRebalance方法。该方法将会遍历consumerTable，获取每一个消费者MQConsumerInner，即DefaultMQPushConsumerImpl或者其他实例，然后通过消费者本身来执行重平衡操作。<br>**</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* MQClientInstance的方法</span></span><br><span class="line"><span class="comment">* &lt;p&gt;</span></span><br><span class="line"><span class="comment">* 执行重平衡</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//遍历consumerTable</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="built_in">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//获取一个消费者，即DefaultMQPushConsumerImpl或者其他实例</span></span><br><span class="line">        <span class="type">MQConsumerInner</span> <span class="variable">impl</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//通过消费者本身来执行重平衡操作</span></span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.error(<span class="string">&quot;doRebalance exception&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><em>MQConsumerInner有三种实现，分别是DefaultLitePullConsumerImpl、DefaultMQPullConsumerImpl、DefaultMQPushConsumerImpl，前两个都用的很少，他们的doRebalance源码也都很简单，即调用各自内部的rebalanceImpl#doRebalance(<br>false)方法即可。</em>*</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.rebalanceImpl != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.rebalanceImpl.doRebalance(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**我们最常使用的是DefaultMQPushConsumerImpl，它的doRebalance方法也很简单，如果该消费者没有暂停，那么同样调用rebalanceImpl#doRebalance方法即可。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQPushConsumerImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 执行重平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果服务没有暂停，那么调用rebalanceImpl执行重平衡</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.pause) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//isConsumeOrderly表示是否是顺序消费</span></span><br><span class="line">        <span class="built_in">this</span>.rebalanceImpl.doRebalance(<span class="built_in">this</span>.isConsumeOrderly());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-RebalanceImpl-doRebalance执行重平衡"><a href="#2-RebalanceImpl-doRebalance执行重平衡" class="headerlink" title="2 RebalanceImpl#doRebalance执行重平衡"></a>2 RebalanceImpl#doRebalance执行重平衡</h2><p>该方法将会获取当前消费者的订阅信息集合，然后遍历订阅信息集合，获取订阅的topic，调用rebalanceByTopic方法对该topic进行重平衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalanceImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 执行重平衡</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isOrder 是否顺序消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取当前消费者的订阅信息集合</span></span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="built_in">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//遍历订阅信息集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//获取topic</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 对该topic进行重平衡</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.warn(<span class="string">&quot;rebalanceByTopic Exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 丢弃不属于当前消费者订阅的topic的队列快照ProcessQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-rebalanceByTopic根据topic执行重平衡"><a href="#3-rebalanceByTopic根据topic执行重平衡" class="headerlink" title="3 rebalanceByTopic根据topic执行重平衡"></a>3 rebalanceByTopic根据topic执行重平衡</h2><p><strong>该方法根据topic进行重平衡，将会根据不同的消息模式执行不同的处理策略。</strong></p>
<p><strong>1、</strong> **如果是广播模式，广播模式下并没有负载均衡可言，每个consumer都会消费所有队列中的全部消息，仅仅是更新当前consumer的处理队列processQueueTable的信息<br>**；<br><strong>2、</strong> **如果是集群模式，首先基于负载均衡策略确定分配给当前消费者的MessageQueue，然后更新当前consumer的处理队列processQueueTable的信息<br>**；</p>
<p><strong>集群模式的大概步骤为：</strong></p>
<p><strong>1、</strong> 首先获取该topic的所有消息队列集合mqSet，随后从topic所在的broker中获取当前consumerGroup的clientId集合，即消费者客户端id集合cidAll一个clientId代表一个消费者；<br><strong>2、</strong> 对topic的消息队列和clientId集合分别进行排序排序能够保证，不同的客户端消费者在进行负载均衡时，其mqAll和cidAll中的元素顺序是一致的；<br><strong>3、</strong> 获取分配消息队列的策略实现AllocateMessageQueueStrategy，即负载均衡的策略类，执行allocate方法，为当前clientId也就是当前消费者，分配消息队列，这一步就是执行负载均衡或者说重平衡的算法；<br><strong>4、</strong><br>调用updateProcessQueueTableInRebalance方法，更新新分配的消息队列的处理队列processQueueTable的信息，为新分配的消息队列创建最初的pullRequest并分发给PullMessageService；<br><strong>5、</strong> 如果processQueueTable发生了改变，那么调用messageQueueChanged方法设置新的本地订阅关系版本，重设流控参数，立即给所有broker发送心跳，让Broker更新当前订阅关系；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalanceImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 根据topic进行重平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//根据不同的消息模式执行不同的处理策略</span></span><br><span class="line">    <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 广播模式的处理</span></span><br><span class="line"><span class="comment">         * 广播模式下并没有负载均衡可言，每个consumer都会消费所有队列中的全部消息，仅仅是更新当前consumer的处理队列processQueueTable的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//获取topic的消息队列</span></span><br><span class="line">            Set&lt;MessageQueue&gt; mqSet = <span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">            <span class="keyword">if</span> (mqSet != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 直接更新全部消息队列的处理队列processQueueTable的信息，创建最初的pullRequest并分发给PullMessageService</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="built_in">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">                <span class="comment">//如果processQueueTable发生了改变</span></span><br><span class="line">                <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 设置新的本地订阅关系版本，重设流控参数，立即给所有broker发送心跳，让Broker更新当前订阅关系</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="built_in">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">                    log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                            consumerGroup,</span><br><span class="line">                            topic,</span><br><span class="line">                            mqSet,</span><br><span class="line">                            mqSet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 集群模式的处理</span></span><br><span class="line"><span class="comment">         * 基于负载均衡策略确定跟配给当前消费者的MessageQueue，然后更新当前consumer的处理队列processQueueTable的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//获取topic的消息队列</span></span><br><span class="line">            Set&lt;MessageQueue&gt; mqSet = <span class="built_in">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 从topic所在的broker中获取当前consumerGroup的clientId集合，即消费者客户端id集合</span></span><br><span class="line"><span class="comment">             * 一个clientId代表一个消费者</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;String&gt; cidAll = <span class="built_in">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == mqSet) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == cidAll) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, consumerGroup, topic);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mqSet != <span class="literal">null</span> &amp;&amp; cidAll != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//将topic的消息队列存入list集合中</span></span><br><span class="line">                List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">                mqAll.addAll(mqSet);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 对topic的消息队列和clientId集合分别进行排序</span></span><br><span class="line"><span class="comment">                 * 排序能够保证，不同的客户端消费者在进行负载均衡时，其mqAll和cidAll中的元素顺序是一致的</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Collections.sort(mqAll);</span><br><span class="line">                Collections.sort(cidAll);</span><br><span class="line">                <span class="comment">//获取分配消息队列的策略实现，即负载均衡的策略类</span></span><br><span class="line">                <span class="type">AllocateMessageQueueStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="built_in">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">                List&lt;MessageQueue&gt; allocateResult = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 为当前clientId也就是当前消费者，分配消息队列</span></span><br><span class="line"><span class="comment">                     * 这一步就是执行负载均衡或者说重平衡的算法</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    allocateResult = strategy.allocate(</span><br><span class="line">                            <span class="built_in">this</span>.consumerGroup,</span><br><span class="line">                            <span class="built_in">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">                            mqAll,</span><br><span class="line">                            cidAll);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(),</span><br><span class="line">                            e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//对消息队列去重</span></span><br><span class="line">                Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;MessageQueue&gt;();</span><br><span class="line">                <span class="keyword">if</span> (allocateResult != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    allocateResultSet.addAll(allocateResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 更新新分配的消息队列的处理队列processQueueTable的信息，创建最初的pullRequest并分发给PullMessageService</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="built_in">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">                <span class="comment">//如果processQueueTable发生了改变</span></span><br><span class="line">                <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.info(</span><br><span class="line">                            <span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>,</span><br><span class="line">                            strategy.getName(), consumerGroup, topic, <span class="built_in">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">                            allocateResultSet.size(), allocateResultSet);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 设置新的本地订阅关系版本，重设流控参数，立即给所有broker发送心跳，让Broker更新当前订阅关系</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="built_in">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-findConsumerIdList查找客户端id集合"><a href="#4-findConsumerIdList查找客户端id集合" class="headerlink" title="4 findConsumerIdList查找客户端id集合"></a>4 findConsumerIdList查找客户端id集合</h2><p>**该方法从topic所在的broker中获取当前consumerGroup的clientId集合，即消费者客户端id集合，用于后续负载均衡策略。一个cliendId代表着一个消费者。<br>**</p>
<ul>
<li><em>首先通过findBrokerAddrByTopic方法随机选择一个当前topic所属的broker，如果broker地址为null则请求nameserver更新topic路由信息。然后调用getConsumerIdListByGroup方法根据brokerAddr和group<br>发起请求到broekr，得到消费者客户端id列表。</em>*</li>
</ul>
<p><strong>从这里的源码能够看出来，RocketMQ一个消费者组内的消费者订阅的topic都必须一致，否则就会出现订阅的topic被覆盖的情况。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQClientInstance的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 从topic所在的broker中获取当前consumerGroup的clientId集合，即消费者客户端id集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findConsumerIdList</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String group)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//随机选择一个当前topic所属的broker</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">brokerAddr</span> <span class="operator">=</span> <span class="built_in">this</span>.findBrokerAddrByTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == brokerAddr) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//如果broker地址为null则请求nameserver更新topic路由信息</span></span><br><span class="line">        <span class="built_in">this</span>.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        brokerAddr = <span class="built_in">this</span>.findBrokerAddrByTopic(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != brokerAddr) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//根据brokerAddr和group 得到消费者客户端id列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.mQClientAPIImpl.getConsumerIdListByGroup(brokerAddr, group, clientConfig.getMqClientApiTimeout());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.warn(<span class="string">&quot;getConsumerIdListByGroup exception, &quot;</span> + brokerAddr + <span class="string">&quot; &quot;</span> + group, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-findBrokerAddrByTopic随机查找broker"><a href="#4-1-findBrokerAddrByTopic随机查找broker" class="headerlink" title="4.1 findBrokerAddrByTopic随机查找broker"></a>4.1 findBrokerAddrByTopic随机查找broker</h3><ul>
<li>*从topicRouteTable中获取topic路由信息，然后随机选择一个broker返回。为社么随机返回就可以呢？因为consumer会向所有broker上报心跳信息，因此这些broker中的客户端id是一致的。并且，RocketMQ默认一个消费者组的所有消费的订阅信息都是一致的，因此随便哪个broker上关于此Group所有ConsumerId集合都是一样的。<br>**</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQClientInstance的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 随机选取指定topic的一个broker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findBrokerAddrByTopic</span><span class="params">(<span class="keyword">final</span> String topic)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取topic路由信息</span></span><br><span class="line">    <span class="type">TopicRouteData</span> <span class="variable">topicRouteData</span> <span class="operator">=</span> <span class="built_in">this</span>.topicRouteTable.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//获取全部broker地址数据</span></span><br><span class="line">        List&lt;BrokerData&gt; brokers = topicRouteData.getBrokerDatas();</span><br><span class="line">        <span class="keyword">if</span> (!brokers.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//随机选择一个broker返回</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(brokers.size());</span><br><span class="line">            <span class="type">BrokerData</span> <span class="variable">bd</span> <span class="operator">=</span> brokers.get(index % brokers.size());</span><br><span class="line">            <span class="keyword">return</span> bd.selectBrokerAddr();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-getConsumerIdListByGroup获取Group所有ConsumerId集合"><a href="#4-2-getConsumerIdListByGroup获取Group所有ConsumerId集合" class="headerlink" title="4.2 getConsumerIdListByGroup获取Group所有ConsumerId集合"></a>4.2 getConsumerIdListByGroup获取Group所有ConsumerId集合</h3><p>该方法向指定地址的broker发起网络请求，查找指定group的全部消费者客户端id列表并返回。请求Code为**GET_CONSUMER_LIST_BY_GROUP<br>**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQClientAPIImpl的方法</span></span><br><span class="line"><span class="comment"> * 根据brokerAddr和group 得到消费者客户端id列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getConsumerIdListByGroup</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String addr,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String consumerGroup,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> timeoutMillis)</span> <span class="keyword">throws</span> RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException,</span><br><span class="line">        MQBrokerException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//构建请求头</span></span><br><span class="line">    <span class="type">GetConsumerListByGroupRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetConsumerListByGroupRequestHeader</span>();</span><br><span class="line">    requestHeader.setConsumerGroup(consumerGroup);</span><br><span class="line">    <span class="comment">//构建请求命令对象，Code为GET_CONSUMER_LIST_BY_GROUP</span></span><br><span class="line">    <span class="type">RemotingCommand</span> <span class="variable">request</span> <span class="operator">=</span> RemotingCommand.createRequestCommand(RequestCode.GET_CONSUMER_LIST_BY_GROUP, requestHeader);</span><br><span class="line">    <span class="comment">//发起同步调用</span></span><br><span class="line">    <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> <span class="built_in">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class="built_in">this</span>.clientConfig.isVipChannelEnabled(), addr),</span><br><span class="line">            request, timeoutMillis);</span><br><span class="line">    <span class="keyword">assert</span> response != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (response.getBody() != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//响应解码</span></span><br><span class="line">                <span class="type">GetConsumerListByGroupResponseBody</span> <span class="variable">body</span> <span class="operator">=</span></span><br><span class="line">                        GetConsumerListByGroupResponseBody.decode(response.getBody(), GetConsumerListByGroupResponseBody.class);</span><br><span class="line">                <span class="comment">//返回客户端id集合</span></span><br><span class="line">                <span class="keyword">return</span> body.getConsumerIdList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQBrokerException</span>(response.getCode(), response.getRemark(), addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-1-broker处理getConsumerListByGroup请求"><a href="#4-2-1-broker处理getConsumerListByGroup请求" class="headerlink" title="4.2.1 broker处理getConsumerListByGroup请求"></a>4.2.1 broker处理getConsumerListByGroup请求</h4><p><strong>broker通过ConsumerManageProcessor对于处理GET_CONSUMER_LIST_BY_GROUP的请求。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConsumerManageProcessor的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br><span class="line">    <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_CONSUMER_LIST_BY_GROUP:</span><br><span class="line">            <span class="comment">//返回指定group的所有客户端id集合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getConsumerListByGroup(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.UPDATE_CONSUMER_OFFSET:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.updateConsumerOffset(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.QUERY_CONSUMER_OFFSET:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.queryConsumerOffset(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-ConsumerManageProcessor-getConsumerListByGroup"><a href="#4-2-2-ConsumerManageProcessor-getConsumerListByGroup" class="headerlink" title="4.2.2 ConsumerManageProcessor#getConsumerListByGroup"></a>4.2.2 ConsumerManageProcessor#getConsumerListByGroup</h4><p>返回指定group的所有客户端id集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConsumerManageProcessor的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 返回指定group的所有客户端id集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">getConsumerListByGroup</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br><span class="line">        <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//创建响应命令对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span></span><br><span class="line">            RemotingCommand.createResponseCommand(GetConsumerListByGroupResponseHeader.class);</span><br><span class="line">    <span class="comment">//解析请求头</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">GetConsumerListByGroupRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span></span><br><span class="line">            (GetConsumerListByGroupRequestHeader) request</span><br><span class="line">                    .decodeCommandCustomHeader(GetConsumerListByGroupRequestHeader.class);</span><br><span class="line">    <span class="comment">//从broker的consumerTable中获取指定group的消费者组信息</span></span><br><span class="line">    <span class="type">ConsumerGroupInfo</span> <span class="variable">consumerGroupInfo</span> <span class="operator">=</span></span><br><span class="line">            <span class="built_in">this</span>.brokerController.getConsumerManager().getConsumerGroupInfo(</span><br><span class="line">                    requestHeader.getConsumerGroup());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (consumerGroupInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//获取所有客户端id集合</span></span><br><span class="line">        List&lt;String&gt; clientIds = consumerGroupInfo.getAllClientId();</span><br><span class="line">        <span class="keyword">if</span> (!clientIds.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="type">GetConsumerListByGroupResponseBody</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetConsumerListByGroupResponseBody</span>();</span><br><span class="line">            body.setConsumerIdList(clientIds);</span><br><span class="line">            response.setBody(body.encode());</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.warn(<span class="string">&quot;getAllClientId failed, &#123;&#125; &#123;&#125;&quot;</span>, requestHeader.getConsumerGroup(),</span><br><span class="line">                    RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        log.warn(<span class="string">&quot;getConsumerGroupInfo failed, &#123;&#125; &#123;&#125;&quot;</span>, requestHeader.getConsumerGroup(),</span><br><span class="line">                RemotingHelper.parseChannelRemoteAddr(ctx.channel()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">    response.setRemark(<span class="string">&quot;no consumer for this group, &quot;</span> + requestHeader.getConsumerGroup());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-allocate分配消息队列"><a href="#5-allocate分配消息队列" class="headerlink" title="5 allocate分配消息队列"></a>5 allocate分配消息队列</h2><p>**AllocateMessageQueueStrategy#allocate方法为当前clientId也就是当前消费者，分配消息队列，这一步实际上就是执行负载均衡或者说重平衡的算法。<br>**</p>
<ul>
<li>*AllocateMessageQueueStrategy是RocketMQ消费者之间消息分配的策略算法接口，RocketMQ已经提供了非常多的算法策略实现类，同时我们自己也可以通过实现AllocateMessageQueueStrategy接口定义自己的负载均衡策略。<br>**</li>
</ul>
<p><strong>注意，在执行负载均衡策略之前，已经对消息队列和消费者进行了排序，因此不同的消费者客户端得到的顺序应该是一致的。</strong></p>
<p>RocketMQ内置了六个负载均衡策略的实现类，我们来看看这些实现类的原理。</p>
<p><strong>1、</strong> <strong>AllocateMessageQueueAveragely</strong>：平均分配策略，这是默认策略尽量将消息队列平均分配给所有消费者，多余的队列分配至排在前面的消费者分配的时候，前一个消费者分配完了，才会给下一个消费者分配；<br><strong>2、</strong> <strong>AllocateMessageQueueAveragelyByCircle</strong><br>：环形平均分配策略尽量将消息队列平均分配给所有消费者，多余的队列分配至排在前面的消费者与平均分配策略差不多，区别就是分配的时候，按照消费者的顺序进行一轮一轮的分配，直到分配完所有消息队列；<br><strong>3、</strong> <strong>AllocateMessageQueueByConfig</strong>：根据用户配置的消息队列分配将会直接返回用户配置的消息队列集合；<br><strong>4、</strong> <strong>AllocateMessageQueueByMachineRoom</strong>：机房平均分配策略消费者只消费绑定的机房中的broker，并对绑定机房中的MessageQueue进行负载均衡；<br><strong>5、</strong> <strong>AllocateMachineRoomNearby</strong><br>：机房就近分配策略消费者对绑定机房中的MessageQueue进行负载均衡除此之外，对于某些拥有消息队列但却没有消费者的机房，其消息队列会被所欲消费者分配，具体的分配策略是，另外传入的一个AllocateMessageQueueStrategy的实现；<br><strong>6、</strong> <strong>AllocateMessageQueueConsistentHash</strong>：一致性哈希分配策略基于一致性哈希算法分配；</p>
<h3 id="5-1-AllocateMessageQueueAveragely平均分配"><a href="#5-1-AllocateMessageQueueAveragely平均分配" class="headerlink" title="5.1 AllocateMessageQueueAveragely平均分配"></a>5.1 AllocateMessageQueueAveragely平均分配</h3><p><strong>计算消息队列数量与消费者数量的商，这个商就是每个消费者都会分到的队列数，然后对于余数，则只有排在前面的消费者能够分配到。</strong></p>
<p>**在进行分配的时候，只有当前一个消费者分配完了，才会分配下一个消费者。例如有消费者A、B，有5个消息队列1、2、3、4、5，计算得到A会分配3分队列，B会分配2个队列，那么将会先给消费者A分配1、2、3，再给消费者B分配到4、5。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Average Hashing queue algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllocateMessageQueueAveragely</span> <span class="keyword">implements</span> <span class="title class_">AllocateMessageQueueStrategy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">log</span> <span class="operator">=</span> ClientLogger.getLog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumerGroup 当前consumerGroup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentCID    当前currentCID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqAll         当前topic的mq，已排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cidAll        当前consumerGroup的clientId集合，已排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span><br><span class="line"><span class="params">                                       List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="literal">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="literal">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="literal">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.info(<span class="string">&quot;[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;&quot;</span>,</span><br><span class="line">                    consumerGroup,</span><br><span class="line">                    currentCID,</span><br><span class="line">                    cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前currentCID在集合中的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cidAll.indexOf(currentCID);</span><br><span class="line">        <span class="comment">//计算平均分配后的余数，大于0表示不能被整除，必然有些消费者会多分配一个队列，有些消费者少分配一个队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> mqAll.size() % cidAll.size();</span><br><span class="line">        <span class="comment">//计算当前消费者分配的队列数量</span></span><br><span class="line">        <span class="comment">//1、如果队列数量小于等于消费者数量，那么每个消费者最多只能分到一个队列，则算作1（后续还会计算），否则，表示每个消费者至少分配一个队列，需要继续计算</span></span><br><span class="line">        <span class="comment">//2、如果mod大于0并且当前消费者索引小于mod，那么当前消费者分到的队列数为平均分配的队列数+1，否则，分到的队列数为平均分配的队列数，即索引在余数范围内的，多分配一个队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">averageSize</span> <span class="operator">=</span></span><br><span class="line">                mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">                        + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">        <span class="comment">//如果mod大于0并且当前消费者索引小于mod，那么起始索引为index * averageSize，否则起始索引为index * averageSize + mod</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line">        <span class="comment">//最终分配的消息队列数量。取最小值是因为有些队列将会分配至较少的队列甚至无法分配到队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">        <span class="comment">//分配队列，按照顺序分配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AVG&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-AllocateMessageQueueAveragelyByCircle环形平均分配"><a href="#5-2-AllocateMessageQueueAveragelyByCircle环形平均分配" class="headerlink" title="5.2 AllocateMessageQueueAveragelyByCircle环形平均分配"></a>5.2 AllocateMessageQueueAveragelyByCircle环形平均分配</h3><p>**按照消费者的顺序进行一轮一轮的分配，直到分配完所有消息队列。例如有消费者A、B，有5个消息队列1、2、3、4、5。第一轮A分配1，B分配2；第二轮A分配3，B分配4；第二轮A分配5。因此A分配到1、3、5，B分配到2、4。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cycle average Hashing queue algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllocateMessageQueueAveragelyByCircle</span> <span class="keyword">implements</span> <span class="title class_">AllocateMessageQueueStrategy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">log</span> <span class="operator">=</span> ClientLogger.getLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span><br><span class="line"><span class="params">        List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="literal">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="literal">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="literal">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.info(<span class="string">&quot;[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;&quot;</span>,</span><br><span class="line">                consumerGroup,</span><br><span class="line">                currentCID,</span><br><span class="line">                cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> cidAll.indexOf(currentCID);</span><br><span class="line">        <span class="comment">//获取每个分配轮次轮次中属于该消费者的对应的消息队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; mqAll.size(); i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (i % cidAll.size() == index) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result.add(mqAll.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AVG_BY_CIRCLE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3AllocateMessageQueueByConfig根据配置分配"><a href="#5-3AllocateMessageQueueByConfig根据配置分配" class="headerlink" title="5.3AllocateMessageQueueByConfig根据配置分配"></a>5.3AllocateMessageQueueByConfig根据配置分配</h3><p>**很简单，如果要想使用该策略，那么应该调用setMessageQueueList方法传入自定义的需要消费的消息队列集合，而allocate方法将直接返回该集合。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllocateMessageQueueByConfig</span> <span class="keyword">implements</span> <span class="title class_">AllocateMessageQueueStrategy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span><br><span class="line"><span class="params">                                       List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//直接返回该集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.messageQueueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CONFIG&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">getMessageQueueList</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> messageQueueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置自定义的消息队列集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageQueueList</span><span class="params">(List&lt;MessageQueue&gt; messageQueueList)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.messageQueueList = messageQueueList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-AllocateMessageQueueByMachineRoom机房平均分配"><a href="#5-4-AllocateMessageQueueByMachineRoom机房平均分配" class="headerlink" title="5.4 AllocateMessageQueueByMachineRoom机房平均分配"></a>5.4 AllocateMessageQueueByMachineRoom机房平均分配</h3><p>**消费者只消费绑定的机房中的broker，并对绑定机房中的MessageQueue进行负载均衡。这种策略要求brokerName的命名必须要按“机房名@brokerName”的格式来设置。<br>**</p>
<p><strong>消费者在分配队列的时候，首先会按照机房名称过滤出所有的 MessageQueue，然后再按照平均分配策略进行分配。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computer room Hashing queue algorithm, such as Alipay logic room</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllocateMessageQueueByMachineRoom</span> <span class="keyword">implements</span> <span class="title class_">AllocateMessageQueueStrategy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//指定消费的机房名集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; consumeridcs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span><br><span class="line"><span class="params">        List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(currentCID)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(mqAll)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(cidAll)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//索引</span></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> cidAll.indexOf(currentCID);</span><br><span class="line">        <span class="keyword">if</span> (currentIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;MessageQueue&gt; premqAll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            String[] temp = mq.getBrokerName().split(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">            <span class="comment">//如果brokerName符合“机房名@brokerName”的格式要求，并且当前消费者的consumeridcs包含该机房，则加入集合</span></span><br><span class="line">            <span class="keyword">if</span> (temp.length == <span class="number">2</span> &amp;&amp; consumeridcs.contains(temp[<span class="number">0</span>])) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                premqAll.add(mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//平均分配的队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> premqAll.size() / cidAll.size();</span><br><span class="line">        <span class="comment">//取模剩余的队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rem</span> <span class="operator">=</span> premqAll.size() % cidAll.size();</span><br><span class="line">        <span class="comment">//分配队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> mod * currentIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> startIndex + mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            result.add(premqAll.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多加一个队列</span></span><br><span class="line">        <span class="keyword">if</span> (rem &gt; currentIndex) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            result.add(premqAll.get(currentIndex + mod * cidAll.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MACHINE_ROOM&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getConsumeridcs</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> consumeridcs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConsumeridcs</span><span class="params">(Set&lt;String&gt; consumeridcs)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.consumeridcs = consumeridcs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="5-5-AllocateMachineRoomNearby机房就近分配"><a href="#5-5-AllocateMachineRoomNearby机房就近分配" class="headerlink" title="5.5 AllocateMachineRoomNearby机房就近分配"></a>5.5 AllocateMachineRoomNearby机房就近分配</h3><p>使用该策略需要传递两个参数：</p>
<p><strong>1、</strong> allocateMessageQueueStrategy：用于真正分配消息队列的策略对象；<br><strong>2、</strong> machineRoomResolver：机房解析器，从clientID和brokerName中解析出机房名称；</p>
<p>该策略的大概逻辑为：</p>
<p><strong>1、</strong> 将消息队列根据机房分组，将消费者根据机房分组；<br><strong>2、</strong> 分配部署在与当前消费者相同的机房中的mq，即如果消息队列与消费者属于同一机房，则对他们进行分配具体的分配策略通过传入的allocateMessageQueueStrategy实现；<br><strong>3、</strong> 如果某个拥有消息队列的机房没有对应的消费者，那么它的消息队列由当前所有的消费者分配具体的分配策略通过传入的allocateMessageQueueStrategy实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * * 基于机房近端优先级的代理分配策略。可以指定实际的分配策略。</span></span><br><span class="line"><span class="comment"> * * 如果任何消费者在机房中活动，则部署在同一台机器中的代理的消息队列应仅分配给这些消费者。</span></span><br><span class="line"><span class="comment"> * * 否则，这些消息队列可以与所有消费者共享，因为没有活跃的消费者来消费它们。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllocateMachineRoomNearby</span> <span class="keyword">implements</span> <span class="title class_">AllocateMessageQueueStrategy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">log</span> <span class="operator">=</span> ClientLogger.getLog();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于真正分配消息队列的策略对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;<span class="comment">//actual allocate strategy</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机房解析器，从clientID和brokerName中解析出机房名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MachineRoomResolver machineRoomResolver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AllocateMachineRoomNearby</span><span class="params">(AllocateMessageQueueStrategy allocateMessageQueueStrategy,</span></span><br><span class="line"><span class="params">                                     MachineRoomResolver machineRoomResolver)</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (allocateMessageQueueStrategy == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;allocateMessageQueueStrategy is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (machineRoomResolver == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;machineRoomResolver is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">        <span class="built_in">this</span>.machineRoomResolver = machineRoomResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span><br><span class="line"><span class="params">                                       List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="literal">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="literal">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="literal">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.info(<span class="string">&quot;[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;&quot;</span>,</span><br><span class="line">                    consumerGroup,</span><br><span class="line">                    currentCID,</span><br><span class="line">                    cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//group mq by machine room</span></span><br><span class="line">        <span class="comment">//将消息队列根据机房分组</span></span><br><span class="line">        Map&lt;String<span class="comment">/*machine room */</span>, List&lt;MessageQueue&gt;&gt; mr2Mq = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String, List&lt;MessageQueue&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//获取broker所属机房</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">brokerMachineRoom</span> <span class="operator">=</span> machineRoomResolver.brokerDeployIn(mq);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNoneEmpty(brokerMachineRoom)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (mr2Mq.get(brokerMachineRoom) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//存入map</span></span><br><span class="line">                    mr2Mq.put(brokerMachineRoom, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加消息队列</span></span><br><span class="line">                mr2Mq.get(brokerMachineRoom).add(mq);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Machine room is null for mq &quot;</span> + mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//group consumer by machine room</span></span><br><span class="line">        <span class="comment">//将消费者根据机房分组</span></span><br><span class="line">        Map&lt;String<span class="comment">/*machine room */</span>, List&lt;String<span class="comment">/*clientId*/</span>&gt;&gt; mr2c = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String cid : cidAll) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//获取消费者所属的机房</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">consumerMachineRoom</span> <span class="operator">=</span> machineRoomResolver.consumerDeployIn(cid);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNoneEmpty(consumerMachineRoom)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">if</span> (mr2c.get(consumerMachineRoom) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//存入map</span></span><br><span class="line">                    mr2c.put(consumerMachineRoom, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加消费者</span></span><br><span class="line">                mr2c.get(consumerMachineRoom).add(cid);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Machine room is null for consumer id &quot;</span> + cid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; allocateResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.allocate the mq that deploy in the same machine room with the current consumer</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 分配部署在与当前消费者相同的机房中的mq</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//获取当前消费者的机房</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentMachineRoom</span> <span class="operator">=</span> machineRoomResolver.consumerDeployIn(currentCID);</span><br><span class="line">        <span class="comment">//移除并获取当前消费者的机房的队列集合</span></span><br><span class="line">        List&lt;MessageQueue&gt; mqInThisMachineRoom = mr2Mq.remove(currentMachineRoom);</span><br><span class="line">        <span class="comment">//获取当前消费者的机房的消费者集合</span></span><br><span class="line">        List&lt;String&gt; consumerInThisMachineRoom = mr2c.get(currentMachineRoom);</span><br><span class="line">        <span class="keyword">if</span> (mqInThisMachineRoom != <span class="literal">null</span> &amp;&amp; !mqInThisMachineRoom.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 调用传入的分配策略，对mqInThisMachineRoom和consumerInThisMachineRoom进行分配</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            allocateResults.addAll(allocateMessageQueueStrategy.allocate(consumerGroup, currentCID, mqInThisMachineRoom, consumerInThisMachineRoom));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.allocate the rest mq to each machine room if there are no consumer alive in that machine room</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果机房中没有的消费者，则将剩余的mq分配给每个机房</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, List&lt;MessageQueue&gt;&gt; machineRoomEntry : mr2Mq.entrySet()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//如果某个拥有消息队列的机房没有对应的消费者，那么它的消息队列由当前所有的消费者分配</span></span><br><span class="line">            <span class="keyword">if</span> (!mr2c.containsKey(machineRoomEntry.getKey())) &#123;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// no alive consumer in the corresponding machine room, so all consumers share these queues</span></span><br><span class="line">                allocateResults.addAll(allocateMessageQueueStrategy.allocate(consumerGroup, currentCID, machineRoomEntry.getValue(), cidAll));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> allocateResults;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MACHINE_ROOM_NEARBY&quot;</span> + <span class="string">&quot;-&quot;</span> + allocateMessageQueueStrategy.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A resolver object to determine which machine room do the message queues or clients are deployed in.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * AllocateMachineRoomNearby will use the results to group the message queues and clients by machine room.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The result returned from the implemented method CANNOT be null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MachineRoomResolver</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        String <span class="title function_">brokerDeployIn</span><span class="params">(MessageQueue messageQueue)</span>;</span><br><span class="line"></span><br><span class="line">        String <span class="title function_">consumerDeployIn</span><span class="params">(String clientID)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-AllocateMessageQueueConsistentHash一致性哈希分配"><a href="#5-6-AllocateMessageQueueConsistentHash一致性哈希分配" class="headerlink" title="5.6 AllocateMessageQueueConsistentHash一致性哈希分配"></a>5.6 AllocateMessageQueueConsistentHash一致性哈希分配</h3><p><strong>使用该策略可以传递两个参数：</strong></p>
<p><strong>1、</strong> <strong>virtualNodeCnt</strong>：物理节点的虚拟节点的数量，不可小于0，默认10；<br><strong>2、</strong> <strong>customHashFunction</strong>：自定义的哈希函数，默认为MD5Hash；</p>
<p><strong>大概步骤为：</strong></p>
<p><strong>1、</strong> <strong>实例化ConsistentHashRouter对象，用于产生虚拟节点以及构建哈希环，如果没有指定哈希函数，则采用MD5Hash作为哈希函数</strong>；<br><strong>2、</strong> <strong>遍历消息队列集合，对messageQueue进行hash计算，按顺时针找到最近的consumer节点如果是当前consumer，则加入结果集</strong>；</p>
<p>**总体上还是比较简单的，但是ConsistentHashRouter的源码还是值得一看的，因为其基于Java实现了一个一致性哈希算法。例如，这里的“哈西环”，实际上是采用TreeMap来实现的。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consistent Hashing queue algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AllocateMessageQueueConsistentHash</span> <span class="keyword">implements</span> <span class="title class_">AllocateMessageQueueStrategy</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">log</span> <span class="operator">=</span> ClientLogger.getLog();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 物理节点的虚拟节点的数量，不可小于0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> virtualNodeCnt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希函数，默认可以为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashFunction customHashFunction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AllocateMessageQueueConsistentHash</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AllocateMessageQueueConsistentHash</span><span class="params">(<span class="type">int</span> virtualNodeCnt)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>(virtualNodeCnt, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AllocateMessageQueueConsistentHash</span><span class="params">(<span class="type">int</span> virtualNodeCnt, HashFunction customHashFunction)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (virtualNodeCnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;illegal virtualNodeCnt :&quot;</span> + virtualNodeCnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.virtualNodeCnt = virtualNodeCnt;</span><br><span class="line">        <span class="built_in">this</span>.customHashFunction = customHashFunction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title function_">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span><br><span class="line"><span class="params">                                       List&lt;String&gt; cidAll)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//参数校验</span></span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="literal">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="literal">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="literal">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.info(<span class="string">&quot;[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;&quot;</span>,</span><br><span class="line">                    consumerGroup,</span><br><span class="line">                    currentCID,</span><br><span class="line">                    cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//包装为ClientNode对象</span></span><br><span class="line">        Collection&lt;ClientNode&gt; cidNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ClientNode&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String cid : cidAll) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            cidNodes.add(<span class="keyword">new</span> <span class="title class_">ClientNode</span>(cid));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实例化ConsistentHashRouter对象，用于产生虚拟节点以及构建哈希环</span></span><br><span class="line">        <span class="comment">//如果没有指定哈希函数，则采用MD5Hash作为哈希函数</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">final</span> ConsistentHashRouter&lt;ClientNode&gt; router; <span class="comment">//for building hash ring</span></span><br><span class="line">        <span class="keyword">if</span> (customHashFunction != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            router = <span class="keyword">new</span> <span class="title class_">ConsistentHashRouter</span>&lt;ClientNode&gt;(cidNodes, virtualNodeCnt, customHashFunction);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            router = <span class="keyword">new</span> <span class="title class_">ConsistentHashRouter</span>&lt;ClientNode&gt;(cidNodes, virtualNodeCnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 遍历消息队列集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//对messageQueue进行hash计算，按顺时针找到最近的consumer节点</span></span><br><span class="line">            <span class="type">ClientNode</span> <span class="variable">clientNode</span> <span class="operator">=</span> router.routeNode(mq.toString());</span><br><span class="line">            <span class="comment">//如果是当前consumer，则加入结果集</span></span><br><span class="line">            <span class="keyword">if</span> (clientNode != <span class="literal">null</span> &amp;&amp; currentCID.equals(clientNode.getKey())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                results.add(mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CONSISTENT_HASH&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClientNode</span> <span class="keyword">implements</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String clientID;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClientNode</span><span class="params">(String clientID)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="built_in">this</span>.clientID = clientID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> clientID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-updateProcessQueueTableInRebalance更新处理队列"><a href="#6-updateProcessQueueTableInRebalance更新处理队列" class="headerlink" title="6 updateProcessQueueTableInRebalance更新处理队列"></a>6 updateProcessQueueTableInRebalance更新处理队列</h2><ul>
<li>*在通过AllocateMessageQueueStrategy#allocate的负载均衡算法为当前消费者分配了新的消息队列之后，需要调用updateProcessQueueTableInRebalance方法，更新新分配的消息队列的处理队列processQueueTable的信息，创建最初的pullRequest并分发给PullMessageService。<br>**</li>
</ul>
<p><strong>该方法非常的重要，大概步骤为：</strong></p>
<p><strong>1、</strong> 遍历当前消费者已分配的所有处理队列processQueueTable，当消费者启动并且第一次执行该方法时，processQueueTable是一个空集合如果当前遍历到的消息队列和当前topic相等：；</p>
<p><strong>1、</strong> <strong>如果新分配的消息队列集合不包含当前遍历到的消息队列，说明这个队列被移除了</strong>；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.  设置对应的处理队列dropped = true，该队列中的消息将不会被消费。</span><br><span class="line">2.  调用removeUnnecessaryMessageQueue删除不必要的消息队列。删除成功后，processQueueTable移除该条目，changed置为true。</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong> **如果当前遍历到的处理队列最后一次拉取消息的时间距离现在超过120s，那么算作消费超时，可能是没有新消息或者网络通信失败<br>**；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.  如果是push消费模式，设置对应的处理队列dropped = true，该队列中的消息将不会被消费。调用**removeUnnecessaryMessageQueue**删除不必要的消息队列。删除成功后，processQueueTable移除该条目，changed置为true。</span><br></pre></td></tr></table></figure>

<p><strong>2、</strong> 创建一个pullRequestList集合，用于存放新增的PullRequest*<br>*遍历新分配的消息队列集合，如果当前消费者的处理队列集合processQueueTable中不包含该消息队列，那么表示这个消息队列是新分配的，需要进行一系列处理：<br>**；</p>
<p><strong>1、</strong> 如果是顺序消费，并且调用lock方法请求broker锁定该队列失败，即获取该队列的分布式锁失败表示新增消息队列失败，这个队列可能还再被其他消费者消费，那么本次重平衡就不再消费该队列，进入下次循环；<br><strong>2、</strong> 如果不是顺序消费或者顺序消费加锁成功，调用removeDirtyOffset方法从offsetTable中移除该消息队列的消费点位offset记录信息；<br><strong>3、</strong> 为该消息队列创建一个处理队列<strong>ProcessQueue</strong>；<br><strong>4、</strong> 调用<strong>computePullFromWhereWithException</strong><br>方法，获取该MessageQueue的下一个消息的消费偏移量nextOffset，pull模式返回0，push模式则根据consumeFromWhere计算得到；<br><strong>5、</strong> 如果nextOffset大于0，表示获取消费位点成功保存当前消息队列MessageQueue和处理队列ProcessQueue关系到processQueueTable；<br><strong>6、</strong> 新建一个<strong>PullRequest</strong>，设置对应的offset、consumerGroup、mq、pq的信息，并且存入pullRequestList集合中*<br>*这里就是最初产生拉取消息请求的地方**changed置为true；<br><strong>3、</strong> 调用dispatchPullRequest方法，分发本次创建的PullRequest请求；</p>
<p><strong>1、</strong> <strong>pull模式需要手动拉取消息，这些请求会作废，因此该方法是一个空实现</strong>；<br><strong>2、</strong> *<br>*push模式下自动拉取消息，而这里的PullRequest就是对应的消息队列的第一个拉取请求，因此这些请求会被PullMessageService依次处理，后续实现自动拉取消息这里就是push模式下最初的产生拉取消息请求的地方<br>**；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalanceImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 更新新分配的消息队列的处理队列processQueueTable的信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic   订阅的主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mqSet   新分配的消息队列集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isOrder 是否顺序消费</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否有变更</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet,</span></span><br><span class="line"><span class="params">                                                   <span class="keyword">final</span> <span class="type">boolean</span> isOrder)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历当前消费者的所有处理队列，当消费者启动并且第一次执行该方法时，processQueueTable是一个空集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="built_in">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">        <span class="comment">//key为消息队列</span></span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> next.getKey();</span><br><span class="line">        <span class="comment">//value为对应的处理队列</span></span><br><span class="line">        <span class="type">ProcessQueue</span> <span class="variable">pq</span> <span class="operator">=</span> next.getValue();</span><br><span class="line">        <span class="comment">//如果topic相等</span></span><br><span class="line">        <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//如果新分配的消息队列集合不包含当前遍历到的消息队列，说明这个队列被移除了</span></span><br><span class="line">            <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//设置对应的处理队列dropped = true，该队列中的消息将不会被消费</span></span><br><span class="line">                pq.setDropped(<span class="literal">true</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 删除不必要的消息队列</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//删除成功后，移除该条目，changed置为true</span></span><br><span class="line">                    it.remove();</span><br><span class="line">                    changed = <span class="literal">true</span>;</span><br><span class="line">                    log.info(<span class="string">&quot;doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果处理队列最后一次拉取消息的时间距离现在超过120s，那么算作消费超时，可能是没有新消息或者网络通信失败</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">switch</span> (<span class="built_in">this</span>.consumeType()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果是push消费模式</span></span><br><span class="line">                    <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">                        <span class="comment">//设置对应的处理队列dropped = true，该队列中的消息将不会被消费</span></span><br><span class="line">                        pq.setDropped(<span class="literal">true</span>);</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * 删除不必要的消息队列</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                            <span class="comment">//删除成功后，移除该条目，changed置为true</span></span><br><span class="line">                            it.remove();</span><br><span class="line">                            changed = <span class="literal">true</span>;</span><br><span class="line">                            log.error(<span class="string">&quot;[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it&quot;</span>,</span><br><span class="line">                                    consumerGroup, mq);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;PullRequest&gt;();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历新分配的消息队列集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//如果当前消费者的处理队列集合中不包含该消息队列，那么表示这个消息队列是新分配的</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//如果是顺序消费，并且请求broker锁定该队列失败，即获取该队列的分布式锁失败</span></span><br><span class="line">            <span class="comment">//表示新增消息队列失败，这个队列可能还再被其他消费者消费，那么本次重平衡就不再消费该队列</span></span><br><span class="line">            <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="built_in">this</span>.lock(mq)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed&quot;</span>, consumerGroup, mq);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从offsetTable中移除该消息队列的消费点位offset记录信息</span></span><br><span class="line">            <span class="built_in">this</span>.removeDirtyOffset(mq);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 为该消息队列创建一个处理队列</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">ProcessQueue</span> <span class="variable">pq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessQueue</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">nextOffset</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 获取该MessageQueue的下一个消息的消费偏移量offset</span></span><br><span class="line"><span class="comment">                 * pull模式返回0，push模式则根据consumeFromWhere计算得到</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                nextOffset = <span class="built_in">this</span>.computePullFromWhereWithException(mq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.info(<span class="string">&quot;doRebalance, &#123;&#125;, compute offset failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果nextOffset大于0，表示获取消费位点成功</span></span><br><span class="line">            <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//保存当前消息队列MessageQueue和处理队列ProcessQueue关系</span></span><br><span class="line">                <span class="type">ProcessQueue</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="built_in">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.info(<span class="string">&quot;doRebalance, &#123;&#125;, mq already exists, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.info(<span class="string">&quot;doRebalance, &#123;&#125;, add a new mq, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 新建一个PullRequest，设置对应的offset、consumerGroup、mq、pq的信息，并且存入pullRequestList集合中</span></span><br><span class="line"><span class="comment">                     * 这里就是最初产生拉取消息请求的地方</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">PullRequest</span> <span class="variable">pullRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PullRequest</span>();</span><br><span class="line">                    pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                    pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                    pullRequest.setMessageQueue(mq);</span><br><span class="line">                    pullRequest.setProcessQueue(pq);</span><br><span class="line">                    pullRequestList.add(pullRequest);</span><br><span class="line">                    <span class="comment">//changed置为true</span></span><br><span class="line">                    changed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;&quot;</span>, consumerGroup, mq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 分发本次创建的PullRequest请求。</span></span><br><span class="line"><span class="comment">     * pull模式需要手动拉取消息，这些请求会作废，因此该方法是一个空实现</span></span><br><span class="line"><span class="comment">     * push模式下自动拉取消息，而这里的PullRequest就是对应的消息队列的第一个拉取请求，因此这些请求会被PullMessageService依次处理，后续实现自动拉取消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-removeUnnecessaryMessageQueue移除非必要的消息队列"><a href="#6-1-removeUnnecessaryMessageQueue移除非必要的消息队列" class="headerlink" title="6.1 removeUnnecessaryMessageQueue移除非必要的消息队列"></a>6.1 removeUnnecessaryMessageQueue移除非必要的消息队列</h3><p><strong>该方法用于尝试移除不必要的消息队列，可能会移除失败。大概步骤为：</strong></p>
<ol>
<li>调用OffsetStore#persist方法，保存指定消息队列的偏移量，可能在本地存储或远程服务器，集群模式保存在远程broker服务器上。</li>
<li>调用OffsetStore#removeOffset方法，移除OffsetStore内部的offsetTable中的对应消息队列的k-v数据。<br><strong>3、</strong> Push模式下，如果当前消费者是有序消费，且是集群消费，那么尝试从Broker端将该消息队列的分布式锁解锁如果是并发消费或者是广播消费，则不进入试解锁的逻辑：；<ol>
<li> 通过consumeLock#tryLock方法尝试获取处理队列的消费锁，最多等待1s。这是一个本地互斥锁，保证在获取到锁以及发起解锁的过程中，没有线程能消费该队列的消息，因为MessageListenerOrderly在消费消息时也需要获取该锁。<br> <strong>2、</strong> 获得锁之后，调用unlockDelay方法延迟的向Broker发送单向请求，Code为UNLOCK_BATCH_MQ，请求Broker释放当前消息队列的分布式锁，<br> <strong>最多延迟20s</strong>该方法一定会返回true；<br> <strong>3、</strong> 在finally中，处理队列的本地消费锁解锁；<br> <strong>4、</strong> **如果没有获得本地锁，那么表示当前消息队列正在消息，不能解锁，那么本次就放弃解锁了，移除消息队列失败，等待下次重新分配消费队列时，再进行移除返回false<br> **；</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalancePushImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 删除不必要的消息队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq 需要删除的消息队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pq 需要删除的消息队列的处理队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeUnnecessaryMessageQueue</span><span class="params">(MessageQueue mq, ProcessQueue pq)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 保存指定消息队列的偏移量，可能在本地存储或远程服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 移除OffsetStore内部的offsetTable中的对应消息队列的k-v数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Push模式下，如果当前消费者是有序消费，且是集群消费，那么尝试从Broker端将该消息队列解锁，如果是并发消费，则不会解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumerImpl.isConsumeOrderly()</span><br><span class="line">            &amp;&amp; MessageModel.CLUSTERING.equals(<span class="built_in">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//尝试获取处理队列的消费锁，最多等待1s</span></span><br><span class="line">            <span class="comment">//这是一个本地互斥锁，保证在获取到锁以及发起解锁的过程中，没有线程能消费该队列的消息</span></span><br><span class="line">            <span class="comment">//因为MessageListenerOrderly在消费消息时也需要获取该锁。</span></span><br><span class="line">            <span class="keyword">if</span> (pq.getConsumeLock().tryLock(<span class="number">1000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 延迟的向Broker发送单向请求，Code为UNLOCK_BATCH_MQ，表示请求Broker释放当前消息队列的分布式锁</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.unlockDelay(mq, pq);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//本地解锁</span></span><br><span class="line">                    pq.getConsumeLock().unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//加锁失败，表示当前消息队列正在消息，不能解锁</span></span><br><span class="line">                <span class="comment">//那么本次就放弃解锁了，移除消息队列失败，等待下次重新分配消费队列时，再进行移除。</span></span><br><span class="line">                log.warn(<span class="string">&quot;[WRONG]mq is consuming, so can not unlock it, &#123;&#125;. maybe hanged for a while, &#123;&#125;&quot;</span>,</span><br><span class="line">                        mq,</span><br><span class="line">                        pq.getTryUnlockTimes());</span><br><span class="line">                <span class="comment">//尝试解锁次数+1</span></span><br><span class="line">                pq.incTryUnlockTimes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.error(<span class="string">&quot;removeUnnecessaryMessageQueue Exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-1-1-unlockDelay延迟解锁"><a href="#6-1-1-unlockDelay延迟解锁" class="headerlink" title="6.1.1 unlockDelay延迟解锁"></a>6.1.1 unlockDelay延迟解锁</h4><p>**向Broker发送单向请求，Code为UNLOCK_BATCH_MQ，表示请求Broker释放当前消息队列的分布式锁。如果消费队列中还有剩余消息，则延迟20s发送解锁请求。<br>**</p>
<p><strong>该方法似乎只会返回true，即只管发送不管结果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalancePushImpl的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 延迟的向Broker发送单向请求，Code为UNLOCK_BATCH_MQ，表示请求Broker释放当前消息队列的分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq 要解锁的消息队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pq 要解锁的消息队列的处理队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 解锁是否成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">unlockDelay</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> ProcessQueue pq)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果消费队列中还有剩余消息，则延迟20s解锁</span></span><br><span class="line">    <span class="keyword">if</span> (pq.hasTempMessage()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        log.info(<span class="string">&quot;[&#123;&#125;]unlockDelay, begin &#123;&#125; &quot;</span>, mq.hashCode(), mq);</span><br><span class="line">        <span class="comment">//延迟20s发送解锁请求</span></span><br><span class="line">        <span class="built_in">this</span>.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.info(<span class="string">&quot;[&#123;&#125;]unlockDelay, execute at once &#123;&#125;&quot;</span>, mq.hashCode(), mq);</span><br><span class="line">                RebalancePushImpl.<span class="built_in">this</span>.unlock(mq, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//立即发送解锁请求</span></span><br><span class="line">        <span class="built_in">this</span>.unlock(mq, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-lock获取分布式锁"><a href="#6-2-lock获取分布式锁" class="headerlink" title="6.2 lock获取分布式锁"></a>6.2 lock获取分布式锁</h3><p>**如果判断到某个消息队列是新分配给当前消费者的，并且如果是顺序消费，那么在当前消费者消费该消息队列之前，需要通过lock方法请求broker获取该队列的分布式锁。如果不是顺序消费，则此时不需要获取分布式锁。<br>**</p>
<p>**如果获取分布式锁失败，那么不会为当前消息队列创建ProcessQueue和PullRequest，因为此时表示该消息队列还不属于当前消费者，不能进行消费，这是RocketMQ保证顺序消费防止重复消费的一个措施。<br>**</p>
<p><strong>1、</strong> 该方法首先调用findBrokerAddressInSubscribe获取指定brokerName的master地址；<br><strong>2、</strong> 然后将当前消费者组、当前客户端id、当前需要被锁定的消息队列等信息封装为一个LockBatchRequestBody，最后向broker发送同步请求，Code为LOCK_BATCH_MQ；<br><strong>3、</strong> Broker返回一个set的MessageQueue集合，表示已经锁住的mq集合，然后编辑集合设置mq对应的processQueue属性，设置locked属性为true，设置加锁的时间属性为当前时间戳；<br><strong>4、</strong> 最后判断如果当前mq在集合中，那么返回true，表示当前mq锁定成功，否则返回false，表示锁定失败；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalanceImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 请求Broker获得指定消息队列的分布式锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq 需要获取分布式锁的消息队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取指定brokerName的master地址</span></span><br><span class="line">    <span class="type">FindBrokerResult</span> <span class="variable">findBrokerResult</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (findBrokerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//构建获取分布式锁的请求体</span></span><br><span class="line">        <span class="type">LockBatchRequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockBatchRequestBody</span>();</span><br><span class="line">        <span class="comment">//当前消费者组</span></span><br><span class="line">        requestBody.setConsumerGroup(<span class="built_in">this</span>.consumerGroup);</span><br><span class="line">        <span class="comment">//当前客户端id</span></span><br><span class="line">        requestBody.setClientId(<span class="built_in">this</span>.mQClientFactory.getClientId());</span><br><span class="line">        <span class="comment">//当前消息队列</span></span><br><span class="line">        requestBody.getMqSet().add(mq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//向broker发送同步请求，Code为LOCK_BATCH_MQ，返回锁住的mq集合</span></span><br><span class="line">            Set&lt;MessageQueue&gt; lockedMq =</span><br><span class="line">                    <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, <span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//遍历锁住的mq集合</span></span><br><span class="line">            <span class="keyword">for</span> (MessageQueue mmqq : lockedMq) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//获取对应的processQueue，设置processQueue的状态</span></span><br><span class="line">                <span class="type">ProcessQueue</span> <span class="variable">processQueue</span> <span class="operator">=</span> <span class="built_in">this</span>.processQueueTable.get(mmqq);</span><br><span class="line">                <span class="keyword">if</span> (processQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//设置locked为true</span></span><br><span class="line">                    processQueue.setLocked(<span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">//设置加锁的时间</span></span><br><span class="line">                    processQueue.setLastLockTimestamp(System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否加锁成功</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">lockOK</span> <span class="operator">=</span> lockedMq.contains(mq);</span><br><span class="line">            log.info(<span class="string">&quot;the message queue lock &#123;&#125;, &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                    lockOK ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;Failed&quot;</span>,</span><br><span class="line">                    <span class="built_in">this</span>.consumerGroup,</span><br><span class="line">                    mq);</span><br><span class="line">            <span class="keyword">return</span> lockOK;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.error(<span class="string">&quot;lockBatchMQ exception, &quot;</span> + mq, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-computePullFromWhereWithException计算offset"><a href="#6-3-computePullFromWhereWithException计算offset" class="headerlink" title="6.3 computePullFromWhereWithException计算offset"></a>6.3 computePullFromWhereWithException计算offset</h3><p>**对于新分配的mq，需要知道从哪个点位开始消费，computePullFromWhereWithException方法就是用来获取该MessageQueue的下一个消息的消费偏移量offset的。<br>**</p>
<p><strong>对于该方法，pull模式固定返回0，因为消费点位需要自己管理，而push模式则根据配置的consumeFromWhere计算得到：</strong></p>
<p><strong>1、</strong><br>CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST、CONSUME_FROM_MIN_OFFSET、CONSUME_FROM_MAX_OFFSET这三种模式已经废弃，默认使用CONSUME_FROM_LAST_OFFSET的逻辑；<br><strong>2、</strong> CONSUME_FROM_LAST_OFFSET：消费者组第一次启动时从最后的位置消费，后续再启动接着上次消费的进度开始消费；<br><strong>3、</strong> CONSUME_FROM_FIRST_OFFSET：消费者组第一次启动时从最开始的位置消费，后续再启动接着上次消费的进度开始消费；<br><strong>4、</strong> CONSUME_FROM_TIMESTAMP：消费者组第一次启动时消费在指定时间戳后产生的消息，后续再启动接着上次消费的进度开始消费；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalancePushImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 计算该MessageQueue的下一个消息的消费偏移量offset</span></span><br><span class="line"><span class="comment"> * pull模式返回0，push模式则根据consumeFromWhere计算得到</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq 需要获取offset的消息队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> offset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">computePullFromWhereWithException</span><span class="params">(MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//获取消费者的ConsumeFromWhere配置，可以通过调用DefaultMQPushConsumer#setConsumeFromWhere方法设置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ConsumeFromWhere</span> <span class="variable">consumeFromWhere</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();</span><br><span class="line">    <span class="comment">//获取offset管理服务</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">OffsetStore</span> <span class="variable">offsetStore</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMQPushConsumerImpl.getOffsetStore();</span><br><span class="line">    <span class="keyword">switch</span> (consumeFromWhere) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//废弃的配置，默认使用CONSUME_FROM_LAST_OFFSET的逻辑</span></span><br><span class="line">        <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST:</span><br><span class="line">        <span class="keyword">case</span> CONSUME_FROM_MIN_OFFSET:</span><br><span class="line">        <span class="keyword">case</span> CONSUME_FROM_MAX_OFFSET:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 消费者组第一次启动时从最后的位置消费，后续再启动接着上次消费的进度开始消费</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 首先读取上次消费进度，pull模式从本地文件读取，push模式从broker读取</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastOffset</span> <span class="operator">=</span> offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">            <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = lastOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//看作是第一次启动，从最后的位置开始消费</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//如果是重试topic，则返回0</span></span><br><span class="line">                <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    result = <span class="number">0L</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//请求broker，获取mq对应ConsumeQueue的最大偏移量，即最新消息索引点位</span></span><br><span class="line">                        result = <span class="built_in">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        log.warn(<span class="string">&quot;Compute consume offset from last offset exception, mq=&#123;&#125;, exception=&#123;&#125;&quot;</span>, mq, e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 消费者组第一次启动时从最开始的位置消费，后续再启动接着上次消费的进度开始消费</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 首先读取上次消费进度，pull模式从本地文件读取，push模式从broker读取</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastOffset</span> <span class="operator">=</span> offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">            <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = lastOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//看作是第一次启动，从最开始的位置开始消费</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = <span class="number">0L</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 消费者组第一次启动时消费在指定时间戳后产生的消息，后续再启动接着上次消费的进度开始消费</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">case</span> CONSUME_FROM_TIMESTAMP: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 首先读取上次消费进度，pull模式从本地文件读取，push模式从broker读取</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastOffset</span> <span class="operator">=</span> offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">            <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = lastOffset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//看作是第一次启动，从指定时间戳后产生的消息的位置开始消费</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//对于重试消息，那么获取mq对应ConsumeQueue的最大偏移量，即最新消息索引点位</span></span><br><span class="line">                <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        result = <span class="built_in">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        log.warn(<span class="string">&quot;Compute consume offset from last offset exception, mq=&#123;&#125;, exception=&#123;&#125;&quot;</span>, mq, e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//解析时间</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> UtilAll.parseDate(<span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),</span><br><span class="line">                                UtilAll.YYYYMMDDHHMMSS).getTime();</span><br><span class="line">                        <span class="comment">//查询指定时间戳之后的消息点位</span></span><br><span class="line">                        result = <span class="built_in">this</span>.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        log.warn(<span class="string">&quot;Compute consume offset from last offset exception, mq=&#123;&#125;, exception=&#123;&#125;&quot;</span>, mq, e);</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                result = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-1-readOffset获取offset"><a href="#6-3-1-readOffset获取offset" class="headerlink" title="6.3.1 readOffset获取offset"></a>6.3.1 readOffset获取offset</h4><p><strong>该方法获取当前消费者组的offset，有三种读取类型：</strong></p>
<p><strong>1、</strong> <strong>READ_FROM_MEMORY</strong>：仅从本地内存offsetTable读取；<br><strong>2、</strong> <strong>READ_FROM_STORE</strong>：仅从broker中读取；<br><strong>3、</strong> <strong>MEMORY_FIRST_THEN_STORE</strong>：先从本地内存offsetTable读取，读不到再从远程broker中读取；<br>当出现异常或者是在本地或者broker没有找到对于消费者组的offset记录，则算作第一次启动该消费者组，那么返回-1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RemoteBrokerOffsetStore的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 获取offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq   需要获取offset的mq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 读取类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">readOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> ReadOffsetType type)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (mq != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 先从本地内存offsetTable读取，读不到再从broker中读取</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">case</span> MEMORY_FIRST_THEN_STORE:</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 仅从本地内存offsetTable读取</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            <span class="keyword">case</span> READ_FROM_MEMORY: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="type">AtomicLong</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="built_in">this</span>.offsetTable.get(mq);</span><br><span class="line">                <span class="keyword">if</span> (offset != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//如果本地内存有关于此mq的offset，那么直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> offset.get();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ReadOffsetType.READ_FROM_MEMORY == type) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//如果本地内存没有关于此mq的offset，但那读取类型为READ_FROM_MEMORY，那么直接返回-1</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 仅从broker中读取</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">case</span> READ_FROM_STORE: &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 从broker中获取此消费者组的offset</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">brokerOffset</span> <span class="operator">=</span> <span class="built_in">this</span>.fetchConsumeOffsetFromBroker(mq);</span><br><span class="line">                    <span class="comment">//更新此mq的offset，并且存入本地offsetTable缓存</span></span><br><span class="line">                    <span class="type">AtomicLong</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(brokerOffset);</span><br><span class="line">                    <span class="built_in">this</span>.updateOffset(mq, offset.get(), <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">return</span> brokerOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No offset in broker</span></span><br><span class="line">                <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//broker中没有关于此消费者组的offset，返回-1</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Other exceptions</span></span><br><span class="line">                <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    log.warn(<span class="string">&quot;fetchConsumeOffsetFromBroker exception, &quot;</span> + mq, e);</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-1-fetchConsumeOffsetFromBroker从broker获取offset"><a href="#6-3-1-1-fetchConsumeOffsetFromBroker从broker获取offset" class="headerlink" title="6.3.1.1 fetchConsumeOffsetFromBroker从broker获取offset"></a>6.3.1.1 fetchConsumeOffsetFromBroker从broker获取offset</h5><p><strong>该方法发起远程请求从broekr中获取只当topic的指定队列的指定消费者组的最新offset。请求Code为QUERY_CONSUMER_OFFSET。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RemoteBrokerOffsetStore</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 从broker中获取此消费者组的offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq 需要获取offset的mq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">fetchConsumeOffsetFromBroker</span><span class="params">(MessageQueue mq)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span><br><span class="line">        InterruptedException, MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取指定brokerName的master地址</span></span><br><span class="line">    <span class="type">FindBrokerResult</span> <span class="variable">findBrokerResult</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == findBrokerResult) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//从nameServer拉取并更新topic的路由信息</span></span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">        <span class="comment">//获取指定brokerName的master地址</span></span><br><span class="line">        findBrokerResult = <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (findBrokerResult != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//构建请求头，包括topic、groupName、queueId</span></span><br><span class="line">        <span class="type">QueryConsumerOffsetRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryConsumerOffsetRequestHeader</span>();</span><br><span class="line">        requestHeader.setTopic(mq.getTopic());</span><br><span class="line">        requestHeader.setConsumerGroup(<span class="built_in">this</span>.groupName);</span><br><span class="line">        requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">        <span class="comment">//向broker发起同步请求获取指定topic的groupName的指定队列的最新偏移量，Code为QUERY_CONSUMER_OFFSET</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().queryConsumerOffset(</span><br><span class="line">                findBrokerResult.getBrokerAddr(), requestHeader, <span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The broker[&quot;</span> + mq.getBrokerName() + <span class="string">&quot;] not exist&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在broker端处理请求Code为QUERY_CONSUMER_OFFSET的方法如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConsumerManageProcessor的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RemotingCommand <span class="title function_">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br><span class="line">        <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">case</span> RequestCode.GET_CONSUMER_LIST_BY_GROUP:</span><br><span class="line">            <span class="comment">//返回指定group的所有客户端id集合</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getConsumerListByGroup(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.UPDATE_CONSUMER_OFFSET:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.updateConsumerOffset(ctx, request);</span><br><span class="line">        <span class="keyword">case</span> RequestCode.QUERY_CONSUMER_OFFSET:</span><br><span class="line">            <span class="comment">//查询消费偏移量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.queryConsumerOffset(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-2-queryConsumerOffset查询消费偏移量"><a href="#6-3-1-2-queryConsumerOffset查询消费偏移量" class="headerlink" title="6.3.1.2 queryConsumerOffset查询消费偏移量"></a>6.3.1.2 queryConsumerOffset查询消费偏移量</h5><p><strong>queryConsumerOffset方法用于broker查询消费者偏移量。</strong></p>
<p><strong>1、</strong> 首先根据ConsumerGroup、Topic、QueueId是从broker端的offsetTable这个map集合缓存属性中获取缓存的消费偏移offset；<br><strong>2、</strong><br>如果offset大于等于0，则直接返回，否则表示缓存中没有对应的消费记录，那么集训判断如果消费队列最新偏移量小于等于0，并且该消费队列的0偏移量数据还在内存中，表示为新消息队列并且消息未清理过，并且数据量不是很大此时，将offset设置为0并返回否则，将会设置QUERY_NOT_FOUND，最后被解析为-1；</p>
<ul>
<li>*从该方法源码可以看出来，消费的consumeFromWhere设置可能不准确，例如一个新的topic里面有少量消息，此时新启动一个consumerGroup去消费，即使consumeFromWhere设置为CONSUME_FROM_LAST_OFFSET，仍然会从0（从头）开始消费。<br>**</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConsumerManageProcessor的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 查询消费偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RemotingCommand <span class="title function_">queryConsumerOffset</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span><br><span class="line">        <span class="keyword">throws</span> RemotingCommandException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//响应对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span></span><br><span class="line">            RemotingCommand.createResponseCommand(QueryConsumerOffsetResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">QueryConsumerOffsetResponseHeader</span> <span class="variable">responseHeader</span> <span class="operator">=</span></span><br><span class="line">            (QueryConsumerOffsetResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">QueryConsumerOffsetRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span></span><br><span class="line">            (QueryConsumerOffsetRequestHeader) request</span><br><span class="line">                    .decodeCommandCustomHeader(QueryConsumerOffsetRequestHeader.class);</span><br><span class="line">    <span class="comment">//根据 ConsumerGroup、Topic、QueueId 查询offset，实际上是从broker端的offsetTable这个map集合缓存属性中获取</span></span><br><span class="line">    <span class="comment">//在broker启动时就从broker的&#123;user.home&#125;/store/config/consumerOffset.json中加载</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span></span><br><span class="line">            <span class="built_in">this</span>.brokerController.getConsumerOffsetManager().queryOffset(</span><br><span class="line">                    requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//大于等于0，则存入响应结果返回</span></span><br><span class="line">        responseHeader.setOffset(offset);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小于0表示在offsetTable缓存中没找到</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//根据topic和queueId获取消费队列ConsumeQueue的最小的逻辑偏移量offset</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">minOffset</span> <span class="operator">=</span></span><br><span class="line">                <span class="built_in">this</span>.brokerController.getMessageStore().getMinOffsetInQueue(requestHeader.getTopic(),</span><br><span class="line">                        requestHeader.getQueueId());</span><br><span class="line">        <span class="comment">//如果消费队列最新偏移量小于等于0，并且该消费队列的0偏移量数据还在内存中，表示为新消息队列并且消息未清理过，并且数据量不是很大</span></span><br><span class="line">        <span class="keyword">if</span> (minOffset &lt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; !<span class="built_in">this</span>.brokerController.getMessageStore().checkInDiskByConsumeOffset(</span><br><span class="line">                requestHeader.getTopic(), requestHeader.getQueueId(), <span class="number">0</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//返回0，从0开始读取消费</span></span><br><span class="line">            responseHeader.setOffset(<span class="number">0L</span>);</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//-1</span></span><br><span class="line">            response.setCode(ResponseCode.QUERY_NOT_FOUND);</span><br><span class="line">            response.setRemark(<span class="string">&quot;Not found, V3_0_6_SNAPSHOT maybe this group consumer boot first&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-dispatchPullRequest分发拉取消息请求PullRequest"><a href="#6-4-dispatchPullRequest分发拉取消息请求PullRequest" class="headerlink" title="6.4 dispatchPullRequest分发拉取消息请求PullRequest"></a>6.4 dispatchPullRequest分发拉取消息请求PullRequest</h3><p><strong>该方法将因为本次新增的消息队列而创建的PullRequest请求进行分发处理。</strong></p>
<p><strong>1、</strong> <strong>pull模式需要手动拉取消息，这些请求会作废，因此该方法是一个空实现</strong>；<br><strong>2、</strong> **push模式下自动拉取消息，而这里的PullRequest就是对应的消息队列的第一个拉取请求，因此这些请求会被PullMessageService依次处理，后续实现自动拉取消息<br>**；</p>
<ul>
<li>*这些PullRequest将会被存入PullMessageService服务内部的pullRequestQueue集合中，后续异步的消费，自动执行拉取消息的请求，这就是Push模式下最初的拉消息请求的来源。关于如何拉去消息以及如何消费，将是我们下一部分的内容。<br>**</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分发处理消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pullRequestList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//遍历拉去请求</span></span><br><span class="line">    <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//将请求存入PullMessageService服务的pullRequestQueue集合中，后续异步的消费，执行拉取消息的请求</span></span><br><span class="line">        <span class="built_in">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">        log.info(<span class="string">&quot;doRebalance, &#123;&#125;, add a new pull request &#123;&#125;&quot;</span>, consumerGroup, pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-messageQueueChanged更新消息队列"><a href="#7-messageQueueChanged更新消息队列" class="headerlink" title="7 messageQueueChanged更新消息队列"></a>7 messageQueueChanged更新消息队列</h2><p>**如果processQueueTable发生了改变，那么调用messageQueueChanged方法。设置新的本地订阅关系版本，重设流控参数，立即给所有broker发送心跳，让Broker更新当前订阅关系。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RebalancePushImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 设置新的本地订阅关系版本，重设流控参数，立即给所有broker发送心跳，让Broker更新当前订阅关系</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic     topic</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mqAll     所有的消息队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mqDivided 分配的消息队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">messageQueueChanged</span><span class="params">(String topic, Set&lt;MessageQueue&gt; mqAll, Set&lt;MessageQueue&gt; mqDivided)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When rebalance result changed, should update subscription&#x27;s version to notify broker.</span></span><br><span class="line"><span class="comment">     * Fix: inconsistency subscription may lead to consumer miss messages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//获取订阅关系</span></span><br><span class="line">    <span class="type">SubscriptionData</span> <span class="variable">subscriptionData</span> <span class="operator">=</span> <span class="built_in">this</span>.subscriptionInner.get(topic);</span><br><span class="line">    <span class="comment">//设置新的版本</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">newVersion</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125; Rebalance changed, also update version: &#123;&#125;, &#123;&#125;&quot;</span>, topic, subscriptionData.getSubVersion(), newVersion);</span><br><span class="line">    subscriptionData.setSubVersion(newVersion);</span><br><span class="line">    <span class="comment">//获取处理队列数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentQueueCount</span> <span class="operator">=</span> <span class="built_in">this</span>.processQueueTable.size();</span><br><span class="line">    <span class="keyword">if</span> (currentQueueCount != <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//topic级别的流量控制阈值，即当前consumer对于Topic在本地最大能缓存的消息数，默认-1，无限制。如果不等于-1，则该值将会被重新计算</span></span><br><span class="line">        <span class="comment">//例如，如果pullThresholdForTopic的值是1000，并且为该消费者分配了10个消息队列，那么pullThresholdForQueue将被设置为100</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pullThresholdForTopic</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdForTopic();</span><br><span class="line">        <span class="comment">//如果不等于-1</span></span><br><span class="line">        <span class="keyword">if</span> (pullThresholdForTopic != -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//取值为 pullThresholdForTopic / currentQueueCount</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newVal</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, pullThresholdForTopic / currentQueueCount);</span><br><span class="line">            log.info(<span class="string">&quot;The pullThresholdForQueue is changed from &#123;&#125; to &#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdForQueue(), newVal);</span><br><span class="line">            <span class="comment">//重设pullThresholdForTopic</span></span><br><span class="line">            <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().setPullThresholdForQueue(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//topic级别的消息缓存大小阈值，即当前consumer对于Topic在本地最大能缓存的消息大小，默认-1，无限制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pullThresholdSizeForTopic</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdSizeForTopic();</span><br><span class="line">        <span class="comment">//如果不等于-1</span></span><br><span class="line">        <span class="keyword">if</span> (pullThresholdSizeForTopic != -<span class="number">1</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//取值为 pullThresholdSizeForTopic / currentQueueCount</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newVal</span> <span class="operator">=</span> Math.max(<span class="number">1</span>, pullThresholdSizeForTopic / currentQueueCount);</span><br><span class="line">            log.info(<span class="string">&quot;The pullThresholdSizeForQueue is changed from &#123;&#125; to &#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdSizeForQueue(), newVal);</span><br><span class="line">            <span class="comment">//重设pullThresholdSizeForTopic</span></span><br><span class="line">            <span class="built_in">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().setPullThresholdSizeForQueue(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// notify broker</span></span><br><span class="line">    <span class="comment">//主动发送心跳信息给所有broker。</span></span><br><span class="line">    <span class="built_in">this</span>.getmQClientFactory().sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p><strong>本次我们学习了DefaultMQPushConsumer负载均衡的具体步骤的源码。集群模式负载均衡的大概步骤为：</strong></p>
<p><strong>1、</strong> 首先获取该topic的所有消息队列集合mqSet，随后从topic所在的broker中获取当前consumerGroup的clientId集合，即消费者客户端id集合cidAll一个clientId代表一个消费者；<br><strong>2、</strong> 对topic的消息队列和clientId集合分别进行排序排序能够保证，不同的客户端消费者在进行负载均衡时，其mqAll和cidAll中的元素顺序是一致的；<br><strong>3、</strong> 获取分配消息队列的策略实现AllocateMessageQueueStrategy，即负载均衡的策略类，执行allocate方法，为当前clientId也就是当前消费者，分配消息队列，这一步就是执行负载均衡或者说重平衡的算法；<br><strong>4、</strong><br>调用updateProcessQueueTableInRebalance方法，更新新分配的消息队列的处理队列processQueueTable的信息，为新分配的消息队列创建最初的pullRequest并分发给PullMessageService<br><strong>这就是Push模式下最初的拉消息请求的来源</strong>；<br><strong>5、</strong> 如果processQueueTable发生了改变，那么调用messageQueueChanged方法设置新的本地订阅关系版本，重设流控参数，立即给所有broker发送心跳，让Broker更新当前订阅关系；</p>
<ul>
<li><p>*同时我们也知道了，最初始的PullRequest，就是在负载均衡之时对于新分配到的消费队列创建的。然后通过dispatchPullRequest方法对这些PullRequest进行分发，Push模式下这些请求会被PullMessageService依次处理，后续实现自动拉取消息，以及消费。<br>**</p>
</li>
<li><p>*这些PullRequest将会被存入PullMessageService服务内部的pullRequestQueue集合中，后续异步的消费，自动执行拉取消息的请求，这就是Push模式下最初的拉消息请求的来源。关于如何拉去消息以及如何消费，将是我们下一部分的内容。<br>**</p>
</li>
</ul>

                
                <p class="end">__END__</p>
            </div>
            <div class="article-footer">
                <div class="suffix-box">
    <div class="suffix-box-left">
        <img src="/image/sidebar/avatar.jpg" alt="Live For Code">
    </div>
    <div class="suffix-box-right">
        <span class="suffix-box-title">文章作者：</span>Live For Code
        <br>
        <span class="suffix-box-title">文章出处：</span><a href="/article/1739713342/" target="_blank">17、RocketMQ源码分析：RebalanceService消费者负载均衡过程源码</a>
        <br>
        <span class="suffix-box-title">作者签名：</span>你知道的越多,你不知道的越多
        <br>
        <span class="suffix-box-title">关于主题：</span><a href="https://fadeway32.gitee.io/" target="_blank">fadeway32</a>
        <br>
        <span class="suffix-box-title">版权声明：</span>文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
        <br>
    </div>
    <div style="clear: both;"></div>
</div>
                
                    <div class="category">
                        分类：
                        
                            <a href="/category/Web/">Web</a>
                        
                    </div>
                
                
                    <div class="tag">
                        标签：
                        
                            <a href="/tag/RocketMq/">RocketMq</a>
                        
                    </div>
                
                <div class="article-prev-next">
                    
                        <a href="/article/1739713343/" class="prev-prefix">« </a> 上一篇：    <a href="/article/1739713343/" title="发布于 2025-02-16 09:42">18、RocketMQ源码分析：DefaultMQPushConsumer消费者发起拉取消息请求源码</a>
                        <br>
                    
                    
                        <a href="/article/1739713345/" class="next-prefix">» </a> 下一篇：    <a href="/article/1739713345/" title="发布于 2025-02-16 09:42">20、RocketMQ源码分析：DefaultMQPushConsumer处理Broker的拉取消息响应源码</a>
                    
                </div>
            </div>
            
    <div class="article-comments">
        
            <div class="comments-title">
                评论列表
            </div>
        
        <div class="comments-content"></div>
    </div>

        </div>
    
</div>
    <div id="footer"></div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        
            <div class="menu-notice">
                <span class="iconfont icon-notice"></span>
                <div class="notice">
                    <span>简单地活着，肆意而又精彩！</span>
                </div>
            </div>
        
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar">
                    <img src="/image/sidebar/avatar.jpg">
                </div> 
                <div class="introduce-info"> 
                    <div class="introduce-user"><span>Live For Code</span></div>
                </div> 
            </div> 
            <div class="menu-list">
                <ul>
                    
                        <li class=""><a href="/" class="" target="_self"><span class="iconfont icon-home-fill"></span>首页</a></li>
                    
                        <li class=""><a href="/category" class="" target="_self"><span class="iconfont icon-folder-fill"></span>分类</a></li>
                    
                        <li class=""><a href="/tag" class="" target="_self"><span class="iconfont icon-discount-fill"></span>标签</a></li>
                    
                        <li class=""><a href="/archive" class="" target="_self"><span class="iconfont icon-calendar-fill"></span>归档</a></li>
                    
                        <li class=""><a href="/donate" class="" target="_self"><span class="iconfont icon-heart-fill"></span>赞赏</a></li>
                    
                        <li class=""><a href="/about" class="" target="_self"><span class="iconfont icon-about-fill"></span>关于</a></li>
                    
                        <li class=""><a href="/atom.xml" class="" target="_blank"><span class="iconfont icon-rss"></span>订阅</a></li>
                    
                        <li class=""><a href="javascript:;" class="search" target="_self"><span class="iconfont icon-search-menu"></span>搜索</a></li>
                    
                        <li class=""><a href="/comment" class="" target="_self"><span class="iconfont icon-comments-fill"></span>留言板</a></li>
                    
                        <li class=""><a href="/friend" class="" target="_self"><span class="iconfont icon-link"></span>友情链接</a></li>
                    
                </ul> 
            </div> 
            <div class="menu-link">
                <div class="box">
                    <div class="image-box"></div>
                </div>
                
                    <a name="知乎" href="https://www.zhihu.com/people/wo-xin-de-love" class="" target="_blank" data=""><span class="iconfont icon-zhihu"></span></a>
                
                    <a name="微博" href="https://weibo.com/u/3939432776" class="" target="_blank" data=""><span class="iconfont icon-weibo"></span></a>
                
                    <a name="QQ" href="javascript:;" class="image" target="_self" data="https://gitee.com/fadeway32/fadeway32/raw/master/img/B5C4BECA9D2E1BBE5B5B9020421E9426.png"><span class="iconfont icon-qq"></span></a>
                
                    <a name="微信" href="javascript:;" class="image" target="_self" data="https://gitee.com/fadeway32/fadeway32/raw/master/img/F35AB4B62DEAE3B5DC2907087E35424E.png"><span class="iconfont icon-wechat"></span></a>
                
                    <a name="GitHub" href="https://github.com/first19326" class="" target="_blank" data=""><span class="iconfont icon-github"></span></a>
                
            </div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="/css/search.css">
<script type="text/javascript" src="/js/iscroll.js"></script>
<script type="text/javascript" src="/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>

    
        <link type="text/css" rel="stylesheet" href="/css/APlayer.css">
        <script type="text/javascript" src="/js/APlayer.min.js"></script>
        <script type="text/javascript" src="/js/Meting.min.js"></script>
        <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>
    
    
    <div class="wrap-right">
        <div class="setting">
            <div class="iconbox favorites" switch="false">
                <span class="iconfont icon-favorites"></span>
                <span class="icontext">关注</span>
            </div>
            <div class="iconbox mode">
                <div class="light">
                    <span class="iconfont icon-daymode"></span>
                    <span class="icontext">浅色模式</span>
                </div>
                <div class="dark">
                    <span class="iconfont icon-nightmode-fill"></span>
                    <span class="icontext">深色模式</span>
                </div>
            </div>
            <a href="javascript:;" target="_self" class="search">
                <div class="iconbox">
                    <span class="iconfont icon-search-menu"></span>
                    <span class="icontext">搜索</span>
                </div>
            </a>
            <div class="iconbox bottom">
                <div style="display: inline-block; transform: rotate(180deg);">
                    <span class="iconfont icon-top"></span>
                </div>
                <span class="icontext">跳至底部</span>
            </div>
        </div>
        <div class="iconbox set">
            <div style="display: inline-block;">
                <span class="iconfont icon-setting"></span>
            </div>
            <span class="icontext">设置</span>
        </div>
        <div class="iconbox top">
            <span class="iconfont icon-top"></span>
            <span class="icontext">返回顶部</span>
        </div>
    </div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : "first19326",
        GitHubRepositories : "Hexo-LiveForCode",

        User             : "Live For Code",
        UserAvatar       : "/image/sidebar/avatar.jpg",
        WebsiteStartDate : "2020-01-01",

        WebsiteTitleBlur         : "(◍´꒳`◍) Hi, Live For Code",
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : "(*´∇｀*) 欢迎回来!",
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : "/image/website/logo.png",

        ProgressBar : {
            id       : "topProgressBar",
            color    : "#77B6FF",
            height   : "2px",
            duration : 0.2
        },

        Loading: {
            rebound : {
                tension  : 16,
                friction : 5
            },
            spinner : {
                id     : "spinner",
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : "#F0F0F0",
                    stroke     : "#272633",
                    base       : "",
                    child      : "#272633"
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : "rgba(255, 255, 255, .2)",
            clearOffset : 0.3
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : "60%",
            colorBrightness  : "50%",
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : "random",
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                "/image/header/home.jpg",
            
                "/image/header/home.jpeg",
            
                "/image/header/2023-04-17-20-51-03.jpg",
            
                "/image/header/2023-04-17-20-54-07.jpg",
            
                "/image/header/2023-04-17-20-54-22.jpg",
            
                "/image/header/2023-04-17-20-55-25.jpg",
            
                "/image/header/2023-04-17-21-04-19.jpg",
            
                "/image/header/2023-04-17-21-04-34.jpg",
            
                "/image/header/2023-04-17-21-04-41.jpg",
            
                "/image/header/2023-04-17-21-05-22.jpg",
            
        ],
        HomeBannerText  : "",

        ArticleHeaderImage : [
            
                "/image/header/article.jpg",
            
                "/image/header/2023-04-17-21-04-19.jpg",
            
                "/image/header/2023-04-17-21-04-34.jpg",
            
                "/image/header/2023-04-17-21-04-41.jpg",
            
                "/image/header/2023-04-17-21-05-22.jpg",
            
        ],

        OtherBannerText : "",

        Error : {
            icon    : "icon-swimming",
            title   : "PAGE NOT FOUND",
            content : [
                
                    "很抱歉，您访问的页面不存在！",
                
                    "可能是输入地址有误或该地址已变更。",
                
            ],
            buttons : [
                
                    {
                        icon  : "icon-home",
                        text  : "返回首页",
                        href  : "https://fadeway32.gitee.io/",
                        class : ""
                    },
                
            ]
        },

        MenuNotice : {
            enable : true,
            notice : "简单地活着，肆意而又精彩！",
            speed  : 20
        },
        MenuList : [
            
                {
                    name   : "首页",
                    icon   : "icon-home-fill",
                    href   : "/",
                    type   : "index",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "分类",
                    icon   : "icon-folder-fill",
                    href   : "/category",
                    type   : "category",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "标签",
                    icon   : "icon-discount-fill",
                    href   : "/tag",
                    type   : "tag",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "归档",
                    icon   : "icon-calendar-fill",
                    href   : "/archive",
                    type   : "archive",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "赞赏",
                    icon   : "icon-heart-fill",
                    href   : "/donate",
                    type   : "donate",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "关于",
                    icon   : "icon-about-fill",
                    href   : "/about",
                    type   : "about",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "订阅",
                    icon   : "icon-rss",
                    href   : "/atom.xml",
                    type   : "",
                    class  : "",
                    target : "_blank"
                },
            
                {
                    name   : "搜索",
                    icon   : "icon-search-menu",
                    href   : "javascript:;",
                    type   : "",
                    class  : "search",
                    target : "_self"
                },
            
                {
                    name   : "留言板",
                    icon   : "icon-comments-fill",
                    href   : "/comment",
                    type   : "comment",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "友情链接",
                    icon   : "icon-link",
                    href   : "/friend",
                    type   : "friend",
                    class  : "",
                    target : "_self"
                },
            
        ],
        MenuLink : [
            
                
                    {
                        name   : "知乎",
                        icon   : "icon-zhihu",
                        href   : "https://www.zhihu.com/people/wo-xin-de-love",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "微博",
                        icon   : "icon-weibo",
                        href   : "https://weibo.com/u/3939432776",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "QQ",
                        icon   : "icon-qq",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "https://gitee.com/fadeway32/fadeway32/raw/master/img/B5C4BECA9D2E1BBE5B5B9020421E9426.png"
                    },
                
                    {
                        name   : "微信",
                        icon   : "icon-wechat",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "https://gitee.com/fadeway32/fadeway32/raw/master/img/F35AB4B62DEAE3B5DC2907087E35424E.png"
                    },
                
                    {
                        name   : "GitHub",
                        icon   : "icon-github",
                        href   : "https://github.com/first19326",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
            
        ],

        FooterStyle : 2,
        BottomText  : "<div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2022 WorstOne. All Rights Reserved.</div>",

        ConsoleList : [
            
                
                    [
                        
                            
                                "Based on cnblogs theme SimpleMemory.",
                            
                                "",
                            
                        
                    ],
                
                    [
                        
                            
                                "SimpleMemory Author:",
                            
                                "BNDong",
                            
                        
                    ],
                
                    [
                        
                            
                                "Theme:",
                            
                                "LiveForCode",
                            
                        
                    ],
                
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : "",
            bitcoin : "",
            alipay  : "/image/donate/alipay.png",
            wechat  : "/image/donate/wechat.png"
        },

        Search : {
            applicationID : "758UIQ1V0H",
            apiKey        : "2e038c318ac6813e4b4baa91f6ccfa63",
            indexName     : "hexo2",
            hits          : {
                page : 30
            },
            labels        : {
                placeholder : "搜索",
                empty       : "未发现与 「${query}」 相关的内容",
                stats       : "${hits} 条相关条目，使用了 ${time} 毫秒",
            }
        }, 

        Valine : {
            switch         : true,
            el             : ".comments-content",
            appId          : "srhKtvWPQTWYKh3qX8G8M7v0-gzGzoHsz",
            appKey         : "8uVSP1q6UlALVC5igYfIfv2h",
            serverURLs     : "",
            placeholder    : "你是我一生只会遇见一次的惊喜...",
            avatar         : "mm",
            meta           : "nick,mail,link",
            requiredFields : "nick,mail",
            pageSize       : 5,
            lang           : "zh-cn",
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : ".toc",
            contentSelector       : ".article-body",
            headingSelector       : "h1, h2, h3, h4, h5",
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : ".toc",
            positionFixedClass    : "toc-fixed",
            fixedSidebarOffset    : "",
        },

        Require : {
            baseUrl     : "/js/",
            waitSeconds : 100
        },

        Music : {
            type : "Meting"
        },
        APlayer : {
            container : ".aplayer",
            fixed     : true,
            autoplay  : true,
            loop      : "all",
            order     : "random",
            preload   : "auto",
            volume    : 0.67,
            mutex     : true,
            lrcType   : 2,
            audio     : [
                
                    {
                        name   : "Endless Tears",
                        artist : "CLIFF EDGE",
                        cover  : "/music/cover/Endless Tears.jpg",
                        url    : "/music/song/Endless Tears.mp3",
                        lrc    : "/music/lrc/Endless Tears.lrc"
                    },
                
            ]
        },
        Meting : {
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        Mouse : {
            enable  : true,
            options : {
                size  : 6,
                sizeF : 24
            }
        },

        LazyLoad : {
            default : "/image/website/lazyload.svg"
        },
  
        Style : {
            aplayer          : "/css/APlayer.css",
            archive          : "/css/archive.css",
            base             : "/css/base.css",
            clipboard        : "/css/clipboard.css",
            code             : "/css/code.css",
            donate           : "/css/donate.css",
            fancybox         : "/css/jquery.fancybox.css",
            footer           : "/css/footer.css",
            iconfont         : "/iconfont/iconfont.css",
            index            : "/css/index.css",
            menuBubble       : "/css/menu-bubble.css",
            mouse            : "/css/mouse.css",
            page             : "/css/page.css",
            post             : "/css/post.css",
            search           : "/css/search.css",
            tocbot           : "/css/tocbot.css",
            valine           : "/css/valine.css"
        },

        Script: {
            aplayer          : "/js/APlayer.min.js",
            config           : "/js/require.config.js",
            index            : "/js/index.js",
            instantSearch    : "/js/instantsearch.min.js",
            iscroll          : "/js/iscroll.js",
            jQuery           : "/js/jquery-3.4.1.min.js",
            loading          : "/js/loading.js",
            meting           : "/js/Meting.min.js",
            require          : "/js/require.min.js"
        },

        Font: {
            LongCang    : "/font/LongCang.css",
            Monda       : "/font/Monda.css",
            NotoSansSC  : "/font/NotoSansSC.css",
            NotoSerifSC : "/font/NotoSerifSC.css",
            Playball    : "/font/Playball.css",
            PTMono      : "/font/PTMono.css",
            Roboto      : "/font/Roboto.css",
            RobotoSlab  : "/font/RobotoSlab.css",
            Rosario     : "/font/Rosario.css",
            UbuntuMono  : "/font/UbuntuMono.css"
        },

        Suffix : {
            about : "你知道的越多,你不知道的越多"
        },
            
        Theme : {
            url  : "https://fadeway32.gitee.io/",
            name : "fadeway32"
        }  
    };
</script>
    <script type="text/javascript" src="/js/index.js"></script>
</body>
</html>