<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <!--    <meta name="referrer" content="origin">-->
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>
        
            07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】
        
    </title>
    <link rel="shortcut icon" href="#"/>

    <link type="text/css" rel="stylesheet" href="/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSerifSC.css">
    <link type="text/css" rel="stylesheet" href="/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="/font/Roboto.css">
    <link type="text/css" rel="stylesheet" href="/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="/css/base.css">
    <link type="text/css" rel="stylesheet" href="/css/code.css">

    <script type="text/javascript" src="/js/jquery-3.4.1.min.js"></script>
<meta name="generator" content="Hexo 6.2.0"></head>
<body>
    <a id="cover"></a>
    <link type="text/css" rel="stylesheet" href="/css/post.css">
<header>
    <meta name="referrer" content="no-referrer">
</header>
<div id="header" class="header">
    <div class="vertical">
        <div class="inner">
            
                <h1 class="header-subtitle">07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2025-02-16
                        </span>
                        
                            <span id="/article/1739713332/" class="leancloud_visitors" data-flag-title="07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】">
                                <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                            </span>
                        
                        <span>
                            <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/article/1739713332/"></span>
                        </span>
                    </p>
                    
                        
                            <span class="category-color">Web</span>
                        
                    
                    
                        
                            <span class="tag-color">RocketMq</span>
                        
                    
                </div>
            
        </div>
    </div>
    
</div>
<div id="container">
    
        <!-- 文章页面 -->
        <div id="article">
            <div class="toc"></div>
            <div class="article-body">
                <h1 id="07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】"><a href="#07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】" class="headerlink" title="07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】"></a>07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】</h1><ul>
<li>1 send源码入口</li>
<li><ul>
<li>1.1 同步消息</li>
</ul>
</li>
<li>1.2 单向消息</li>
<li>1.3 异步消息</li>
<li>2 sendDefaultImpl发送消息实现</li>
<li><ul>
<li>2.1 makeSureStateOK确定生产者服务状态</li>
</ul>
</li>
<li>2.2 checkMessage校验消息的合法性</li>
<li>2.3 tryToFindTopicPublishInfo查找topic的发布信息</li>
<li>2.4 计算发送次数timesTotal</li>
<li>2.5 selectOneMessageQueue选择消息队列</li>
<li><ul>
<li>2.5.1 selectOneMessageQueue选择一个mq</li>
</ul>
</li>
<li>2.6 sendKernelImpl发送消息</li>
<li><ul>
<li>2.6.1 findBrokerAddressInPublish查找broker地址</li>
<li>2.6.2 brokerVIPChannel判断vip通道</li>
<li>2.6.3 setUniqID生成uniqId</li>
<li>2.6.4 tryToCompressMessage压缩消息</li>
</ul>
</li>
<li>2.7 updateFaultItem更新故障表</li>
<li><ul>
<li>2.7.1 computeNotAvailableDuration计算隔离时间</li>
<li>2.7.2 updateFaultItem更新故障表</li>
</ul>
</li>
<li>3 总结</li>
</ul>
<p>下面是一个最简单的producer的使用案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Instantiate with a producer group name.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Launch the instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Topic1&quot;</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span>).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Call send message to deliver message to one of brokers.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到producer通过调用send方法发送消息，实际上RocketMQ的producer发送消息的模式可以分为三种：</p>
<p><strong>1、</strong> <strong>单向发送</strong>：把消息发向Broker服务器，而不用管消息是否成功发送到Broker服务器，只管发送，不管结果；<br><strong>2、</strong> <strong>同步发送</strong>：把消息发送给Broker服务器，如果消息成功发送给Broker服务器，能得到Broker服务器的响应结果；<br><strong>3、</strong> <strong>异步发送</strong>：把消息发送给Broker服务器，如果消息成功发送给Broker服务器，能得到Broker服务器的响应结果因为是异步发送，发送完消息以后，不用等待，等到Broker服务器的响应调用回调；</p>
<p>DefaultMQProducer提供了更多的send的重载方法，来实现上面三种发送模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同步</td>
<td align="left">SendResult send(Collection msgs)</td>
<td align="left">同步批量发送消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Collection msgs, long timeout)</td>
<td align="left">同步批量发送消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Collection msgs, MessageQueue messageQueue)</td>
<td align="left">向指定的消息队列同步批量发送消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Collection msgs, MessageQueue messageQueue, long timeout)</td>
<td align="left">向指定的消息队列同步批量发送消息，并指定超时时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Message msg)</td>
<td align="left">同步单条发送消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Message msg, long timeout)</td>
<td align="left">同步发送单条消息，并指定超时时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Message msg, MessageQueue mq)</td>
<td align="left">向指定的消息队列同步发送单条消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Message msg, MessageQueue mq, long timeout)</td>
<td align="left">向指定的消息队列同步单条发送消息，并指定超时时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Message msg, MessageQueueSelector selector, Object arg)</td>
<td align="left">向消息队列同步单条发送消息，并指定发送队列选择器</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">SendResult send(Message msg, MessageQueueSelector selector, Object arg, long timeout)</td>
<td align="left">向消息队列同步单条发送消息，并指定发送队列选择器与超时时间</td>
</tr>
<tr>
<td align="left">异步</td>
<td align="left">void send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback)</td>
<td align="left">向指定的消息队列异步单条发送消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void send(Message msg, MessageQueueSelector selector, Object arg, SendCallback sendCallback, long timeout)</td>
<td align="left">向指定的消息队列异步单条发送消息，并指定超时时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void send(Message msg, SendCallback sendCallback)</td>
<td align="left">异步发送消息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void send(Message msg, SendCallback sendCallback, long timeout)</td>
<td align="left">异步发送消息，并指定回调方法和超时时间</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void send(Message msg, MessageQueue mq, SendCallback sendCallback)</td>
<td align="left">向指定的消息队列异步单条发送消息，并指定回调方法</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void send(Message msg, MessageQueue mq, SendCallback sendCallback, long timeout)</td>
<td align="left">向指定的消息队列异步单条发送消息，并指定回调方法和超时时间</td>
</tr>
<tr>
<td align="left">单向</td>
<td align="left">void sendOneway(Message msg)</td>
<td align="left">单向发送消息，不等待broker响应</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void sendOneway(Message msg, MessageQueue mq)</td>
<td align="left">单向发送消息到指定队列，不等待broker响应</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void sendOneway(Message msg, MessageQueueSelector selector, Object arg)</td>
<td align="left">单向发送消息到队列选择器的选中的队列，不等待broker响应</td>
</tr>
</tbody></table>
<p>上次我们分析了producer的启动流程源码，这次我们分析producer发送消息的源码。</p>
<h2 id="1-send源码入口"><a href="#1-send源码入口" class="headerlink" title="1 send源码入口"></a>1 send源码入口</h2><p>DefaultMQProducer#send方法作为源码分析的入口方法，该方法被使用者直接调用。其内部调用defaultMQProducerImpl#send方法发送消息。</p>
<h3 id="1-1-同步消息"><a href="#1-1-同步消息" class="headerlink" title="1.1 同步消息"></a>1.1 同步消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(</span></span><br><span class="line"><span class="params">        Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//根据namespace设置topic</span></span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="comment">//调用defaultMQProducerImpl#send发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultMQProducerImpl.send(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部调用defaultMQProducerImpl#send发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(</span></span><br><span class="line"><span class="params">        Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调用另一个send方法，设置超时时间参数，默认3000ms</span></span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="built_in">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部又调用另一个send方法，设置超时时间参数，默认3000ms。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg     消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 超时时间，毫秒值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SendResult <span class="title function_">send</span><span class="params">(Message msg,</span></span><br><span class="line"><span class="params">                       <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调用另一个sendDefaultImpl方法，设置消息发送模式为SYNC，即同步；设置回调函数为null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="literal">null</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部又调用另一个sendDefaultImpl方法，设置消息发送模式为SYNC，即同步；设置回调函数为null。</p>
<h3 id="1-2-单向消息"><a href="#1-2-单向消息" class="headerlink" title="1.2 单向消息"></a>1.2 单向消息</h3><p>单向消息使用sendOneway发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneway</span><span class="params">(Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span><br><span class="line"> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//根据namespace设置topic</span></span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="comment">//调用defaultMQProducerImpl#sendOneway发送消息</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducerImpl.sendOneway(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部调用defaultMQProducerImpl#sendOneway。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneway</span><span class="params">(Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//调用sendDefaultImpl方法，设置消息发送模式为ONEWAY，即单向；设置回调函数为null；设置超时时间参数，默认3000ms</span></span><br><span class="line">        <span class="built_in">this</span>.sendDefaultImpl(msg, CommunicationMode.ONEWAY, <span class="literal">null</span>, <span class="built_in">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;unknown exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用sendDefaultImpl方法，设置消息发送模式为ONEWAY，即单向；设置回调函数为null；设置超时时间参数，默认3000ms。</p>
<h3 id="1-3-异步消息"><a href="#1-3-异步消息" class="headerlink" title="1.3 异步消息"></a>1.3 异步消息</h3><p>异步消息使用带有callback函数的send方法发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Message msg,                 SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException,</span><br><span class="line"> RemotingException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//根据namespace设置topic</span></span><br><span class="line">    msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="comment">//调用defaultMQProducerImpl#send发送消息，带有sendCallback参数</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQProducerImpl.send(msg, sendCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部调用defaultMQProducerImpl#send方法发送消息，带有sendCallback参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(Message msg,                 SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, </span><br><span class="line">RemotingException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//该方法内部又调用另一个send方法，设置超时时间参数，默认3000ms。</span></span><br><span class="line">    send(msg, sendCallback, <span class="built_in">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部又调用另一个send方法，设置超时时间参数，默认3000ms。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="type">long</span> timeout)</span></span><br><span class="line">        <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调用起始时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">beginStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//获取异步发送执行器线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.getAsyncSenderExecutor();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 使用线程池异步的执行sendDefaultImpl方法，即异步发送消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        executor.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 发送之前计算超时时间，如果超时则不发送，直接执行回调函数onException方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; costTime) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//调用sendDefaultImpl方法执行发送操作</span></span><br><span class="line">                        sendDefaultImpl(msg, CommunicationMode.ASYNC, sendCallback, timeout - costTime);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//抛出异常，执行回调函数onException方法</span></span><br><span class="line">                        sendCallback.onException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//超时，执行回调函数onException方法</span></span><br><span class="line">                    sendCallback.onException(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;DEFAULT ASYNC send call timeout&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;executor rejected &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法内部会获取获取异步发送执行器线程池，使用线程池异步的执行sendDefaultImpl方法，即异步发送消息。</p>
<p>发送之前计算超时时间，如果超时则不发送，直接执行回调函数onException方法。</p>
<h2 id="2-sendDefaultImpl发送消息实现"><a href="#2-sendDefaultImpl发送消息实现" class="headerlink" title="2 sendDefaultImpl发送消息实现"></a>2 sendDefaultImpl发送消息实现</h2><p>该方法位于DefaultMQProducerImpl中，无论是同步消息、异步消息还是单向消息，最终都是调用该方法实现发送消息的逻辑的，因此该方法是真正的发送消息的方法入口。</p>
<p>该方法的大概步骤为：</p>
<p><strong>1、</strong> 调用makeSureStateOK方法，确定此producer的服务状态正常，如果服务状态不是RUNNING，那么抛出异常；<br><strong>2、</strong> 调用checkMessage方法，校验消息的合法性；<br><strong>3、</strong> 调用tryToFindTopicPublishInfo方法，尝试查找消息的一个topic路由，用以发送消息；<br><strong>4、</strong> 计算循环发送消息的总次数timesTotal，默认情况下，同步模式为3，即默认允许重试2次，可更改重试次数；其他模式为1，即不允许重试，不可更改实际上异步发送消息也会重试，最多两次，只不过不是通过这里的逻辑重试的；<br><strong>5、</strong> 调用selectOneMessageQueue方法，选择一个消息队列MessageQueue，该犯法支持失败故障转移；<br><strong>6、</strong> 调用sendKernelImpl方法发送消息，异步、同步、单向发送消息的模式都是通过该方法实现的；<br><strong>7、</strong> 调用updateFaultItem方法，更新本地错误表缓存数据，用于延迟时间的故障转移的功能；<br><strong>8、</strong> 根据发送模式执行不同的处理，如果是异步或者单向模式则直接返回，如果是同步模式，如果开启了retryAnotherBrokerWhenNotStoreOK开关，那么如果返回值不是返回SEND_OK状态，则仍然会执行重试发送；<br><strong>9、</strong><br>此过程中，如果抛出了RemotingException、MQClientException、以及部分MQBrokerException异常时，那么会进行重试，如果抛出了InterruptedException，或者因为超时则不再重试；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg               方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> communicationMode 通信模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sendCallback      回调方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout           超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendDefaultImpl</span><span class="params">(</span></span><br><span class="line"><span class="params">        Message msg,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SendCallback sendCallback,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> timeout</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1 确定此producer的服务状态正常，如果服务状态不是RUNNING，那么抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.makeSureStateOK();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 2 校验消息的合法性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Validators.checkMessage(msg, <span class="built_in">this</span>.defaultMQProducer);</span><br><span class="line">    <span class="comment">//生成本次调用id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">invokeID</span> <span class="operator">=</span> random.nextLong();</span><br><span class="line">    <span class="comment">//开始时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTimestampFirst</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTimestampPrev</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line">    <span class="comment">//结束时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">endTimestamp</span> <span class="operator">=</span> beginTimestampFirst;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 3 尝试查找消息的一个topic路由，用以发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">TopicPublishInfo</span> <span class="variable">topicPublishInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    <span class="comment">//找到有效的topic信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo != <span class="literal">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">callTimeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 4 计算发送消息的总次数</span></span><br><span class="line"><span class="comment">         * 同步模式为3，即默认允许重试2次，可更改重试次数；其他模式为1，即不允许重试，不可更改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">timesTotal</span> <span class="operator">=</span> communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录每一次重试时候发送消息目标Broker名字的数组</span></span><br><span class="line">        String[] brokersSent = <span class="keyword">new</span> <span class="title class_">String</span>[timesTotal];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在循环中，发送消息，包含消息重试的逻辑，总次数默认不超过3</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//上次使用过的broker，可以为空，表示第一次选择</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">lastBrokerName</span> <span class="operator">=</span> <span class="literal">null</span> == mq ? <span class="literal">null</span> : mq.getBrokerName();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 5 选择一个消息队列MessageQueue</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mqSelected</span> <span class="operator">=</span> <span class="built_in">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">            <span class="keyword">if</span> (mqSelected != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                mq = mqSelected;</span><br><span class="line">                <span class="comment">//设置brokerName</span></span><br><span class="line">                brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//调用的开始时间</span></span><br><span class="line">                    beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">//如果还有可调用次数，那么</span></span><br><span class="line">                    <span class="keyword">if</span> (times &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//在重新发送期间用名称空间重置topic</span></span><br><span class="line">                        msg.setTopic(<span class="built_in">this</span>.defaultMQProducer.withNamespace(msg.getTopic()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//现在调用的开始时间 减去 开始时间，判断时候在调用发起之前就超时了</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">costTime</span> <span class="operator">=</span> beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                    <span class="comment">//如果已经超时了，那么直接结束循环，不再发送</span></span><br><span class="line">                    <span class="comment">//即超时的时候，即使还剩下重试次数，也不会再继续重试</span></span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        callTimeout = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 6 异步、同步、单向发送消息</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    sendResult = <span class="built_in">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                    <span class="comment">//方法调用结束时间戳</span></span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 7 更新本地错误表缓存数据，用于延迟时间的故障转移的功能</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 8 根据发送模式执行不同的处理</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//异步和单向模式直接返回null</span></span><br><span class="line">                        <span class="keyword">case</span> ASYNC:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">case</span> SYNC:</span><br><span class="line">                            <span class="comment">//同步模式，如果开启了retryAnotherBrokerWhenNotStoreOK开关，那么如果不是返回SEND_OK状态，则仍然会执行重试发送</span></span><br><span class="line">                            <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                                <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果发送成功，则返回</span></span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//RemotingException异常，会执行重试</span></span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//MQClientException异常，会执行重试</span></span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//MQBrokerException异常</span></span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">true</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    exception = e;</span><br><span class="line">                    <span class="comment">//如果返回的状态码属于一下几种，则支持重试：</span></span><br><span class="line">                    <span class="comment">//ResponseCode.TOPIC_NOT_EXIST,</span></span><br><span class="line">                    <span class="comment">//ResponseCode.SERVICE_NOT_AVAILABLE,</span></span><br><span class="line">                    <span class="comment">//ResponseCode.SYSTEM_ERROR,</span></span><br><span class="line">                    <span class="comment">//ResponseCode.NO_PERMISSION,</span></span><br><span class="line">                    <span class="comment">//ResponseCode.NO_BUYER_ID,</span></span><br><span class="line">                    <span class="comment">//ResponseCode.NOT_IN_CURRENT_UNIT</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQProducer.getRetryResponseCodes().contains(e.getResponseCode())) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//其他状态码不支持重试，如果有结果则返回，否则直接抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (sendResult != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                            <span class="keyword">return</span> sendResult;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//InterruptedException异常，不会执行重试</span></span><br><span class="line">                    endTimestamp = System.currentTimeMillis();</span><br><span class="line">                    <span class="built_in">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="literal">false</span>);</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s&quot;</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                    log.warn(<span class="string">&quot;sendKernelImpl exception&quot;</span>, e);</span><br><span class="line">                    log.warn(msg.toString());</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 抛出异常的操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sendResult != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(<span class="string">&quot;Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s&quot;</span>,</span><br><span class="line">                times,</span><br><span class="line">                System.currentTimeMillis() - beginTimestampFirst,</span><br><span class="line">                msg.getTopic(),</span><br><span class="line">                Arrays.toString(brokersSent));</span><br><span class="line"></span><br><span class="line">        info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line"></span><br><span class="line">        <span class="type">MQClientException</span> <span class="variable">mqClientException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(info, exception);</span><br><span class="line">        <span class="keyword">if</span> (callTimeout) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;sendDefaultImpl call timeout&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQBrokerException) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingConnectException) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingTimeoutException) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> MQClientException) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> mqClientException;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validateNameServerSetting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;No route info of this topic: &quot;</span> + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line">            <span class="literal">null</span>).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-makeSureStateOK确定生产者服务状态"><a href="#2-1-makeSureStateOK确定生产者服务状态" class="headerlink" title="2.1 makeSureStateOK确定生产者服务状态"></a>2.1 makeSureStateOK确定生产者服务状态</h3><p>首先会确定此producer的服务状态正常，如果服务状态不是RUNNING，那么抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeSureStateOK</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//服务状态不是RUNNING，那么抛出MQClientException异常。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.serviceState != ServiceState.RUNNING) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The producer service state not OK, &quot;</span></span><br><span class="line">                + <span class="built_in">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-checkMessage校验消息的合法性"><a href="#2-2-checkMessage校验消息的合法性" class="headerlink" title="2.2 checkMessage校验消息的合法性"></a>2.2 checkMessage校验消息的合法性</h3><p>确定服务状态正常之后，还需要校验消息的合法性。校验规则为：</p>
<p><strong>1、</strong> 如果msg消息为null，抛出异常；<br><strong>2、</strong> 校验topic如果topic为空，或者长度大于127个字符，或者topic的字符串不符合”^[%|a-zA-Z0-9_-]+$”<br>模式，即包含非法字符，那么抛出异常如果当前topic是不为允许使用的系统topic，那么抛出异常；<br><strong>3、</strong> 校验消息体如果消息体为null，或者为空数组，或者消息字节数组长度大于4,194,304，即消息的大小大于4M，那么抛出异常；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Validators的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果消息为null，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == msg) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 校验topic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如果topic为空，或者长度大于127个字符，或者topic的字符串不符合 &quot;^[%|a-zA-Z0-9_-]+$&quot;模式，即包含非法字符，那么抛出异常</span></span><br><span class="line">    Validators.checkTopic(msg.getTopic());</span><br><span class="line">    <span class="comment">//如果当前topic是不为允许使用的系统topic SCHEDULE_TOPIC_XXXX，那么抛出异常</span></span><br><span class="line">    Validators.isNotAllowedSendTopic(msg.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">    <span class="comment">//如果消息体为null，那么抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == msg.getBody()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message body is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果消息体为空数组，那么抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL, <span class="string">&quot;the message body length is zero&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果消息 字节数组长度大于4,194,304，即消息的大小大于4M，那么抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(ResponseCode.MESSAGE_ILLEGAL,</span><br><span class="line">                <span class="string">&quot;the message body size over max value, MAX: &quot;</span> + defaultMQProducer.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkTopic</span><span class="params">(String topic)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果topic为空，那么抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (UtilAll.isBlank(topic)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The specified topic is blank&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果topic长度大于127个字符，那么抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (topic.length() &gt; TOPIC_MAX_LENGTH) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;The specified topic is longer than topic max length %d.&quot;</span>, TOPIC_MAX_LENGTH), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果topic字符串包含非法字符，那么抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (isTopicOrGroupIllegal(topic)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(String.format(</span><br><span class="line">                <span class="string">&quot;The specified topic[%s] contains illegal characters, allowing only %s&quot;</span>, topic,</span><br><span class="line">                <span class="string">&quot;^[%|a-zA-Z0-9_-]+$&quot;</span>), <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-tryToFindTopicPublishInfo查找topic的发布信息"><a href="#2-3-tryToFindTopicPublishInfo查找topic的发布信息" class="headerlink" title="2.3 tryToFindTopicPublishInfo查找topic的发布信息"></a>2.3 tryToFindTopicPublishInfo查找topic的发布信息</h3><p>该方法用于查找指定topic的发布信息TopicPublishInfo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 查找指定topic的推送信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TopicPublishInfo <span class="title function_">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//尝试直接从producer的topicPublishInfoTable中获取topic信息</span></span><br><span class="line">    <span class="type">TopicPublishInfo</span> <span class="variable">topicPublishInfo</span> <span class="operator">=</span> <span class="built_in">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">//如果没有获取到有效信息，</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//那么立即创建一个TopicPublishInfo</span></span><br><span class="line">        <span class="built_in">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> <span class="title class_">TopicPublishInfo</span>());</span><br><span class="line">        <span class="comment">//立即从nameServer同步此topic的路由配置信息，并且更新本地缓存</span></span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        <span class="comment">//再次获取topicPublishInfo</span></span><br><span class="line">        topicPublishInfo = <span class="built_in">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找到的路由信息是可用的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//再次从nameServer同步topic的数据，不过这次使用默认的topic “TBW102”去找路由配置信息作为本topic参数信息</span></span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="literal">true</span>, <span class="built_in">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="built_in">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在本地缓存topicPublishInfoTable获取，如果没有获取到有效数据，那么立即调用updateTopicRouteInfoFromNameServer方法从nameServer同步此topic的路由配置信息，并且更新本地缓存，如果还是没有获取到有效数据，那么再次从nameServer同步topic的数据，不过这次使用默认的topic<br>“TBW102”去找路由配置信息作为本topic参数信息。</p>
<p>updateTopicRouteInfoFromNameServer 方法我们在此前的producer启动流程中已经介绍了。<br>TopicPublishInfo包含topic的各种属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是顺序消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">orderTopic</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否包含路由信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">haveTopicRouterInfo</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topic的消息队列集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MessageQueue&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前线程线程的消息队列的下标，循环选择消息队列使用+1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">ThreadLocalIndex</span> <span class="variable">sendWhichQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalIndex</span>();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topic路由信息，包括topic的队列信息queueDatas，topic的broker信息brokerDatas，顺序topic配置orderTopicConf，消费过滤信息filterServerTable等属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-计算发送次数timesTotal"><a href="#2-4-计算发送次数timesTotal" class="headerlink" title="2.4 计算发送次数timesTotal"></a>2.4 计算发送次数timesTotal</h3><p><strong>在发送消息之前，会先计算最大发送次数，同步模式为3，即默认允许重试2次，可更改重试次数；其他模式为1，即不允许重试，不可更改。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">timesTotal</span> <span class="operator">=</span> communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + </span><br><span class="line"><span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>**注意，异步发送同样有重试，并且也是两次，只不过它的重试不在这个循环里面，而是是在MQClientAPIImpl#sendMessage方法中，后面会讲到。<br>**</p>
<h3 id="2-5-selectOneMessageQueue选择消息队列"><a href="#2-5-selectOneMessageQueue选择消息队列" class="headerlink" title="2.5 selectOneMessageQueue选择消息队列"></a>2.5 selectOneMessageQueue选择消息队列</h3><p><strong>selectOneMessageQueue</strong>方法用于查找一个可用的消息队列，该方法内部调用<strong>mqFaultStrategy#selectOneMessageQueue</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 选择一个消息队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tpInfo topic信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastBrokerName 上次使用过的broker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调用mqFaultStrategy#selectOneMessageQueue方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mqFaultStrategy#selectOneMessageQueue</strong>方法支持故障转移机制，其选择步骤为：</p>
<p><strong>1、</strong> 首先判断是否开启了发送延迟故障转移机制，即sendLatencyFaultEnable属性是否为true，默认false不打开如果开启了该机制：；</p>
<p><strong>1、</strong><br>首先仍然是遍历消息队列，按照轮询的方式选取一个消息队列，当消息队列可用（无故障）时，选择消息队列的工作就结束，否则循环选择其他队列如果该mq的broker不存在LatencyFaultTolerance维护的faultItemTable集合属性中，或者当前时间戳已经大于该broker下一次开始可用的时间戳，表示无故障；<br><strong>2、</strong><br>没有选出无故障的mq，那么从LatencyFaultTolerance维护的不是最好的broker集合faultItemTable中随机选择一个broker，随后判断如果写队列数大于0，那么选择该broker然后遍历消息队列，采用取模的方式获取一个队列，即轮询的方式，重置其brokerName，queueId，进行消息发送；<br><strong>3、</strong> 如果上面的步骤抛出了异常，那么遍历消息队列，采用取模的方式获取一个队列，即轮询的方式；<br><strong>2、</strong><br>如果没有发送延迟故障转移机制，那么那么遍历消息队列，即采用取模轮询的方式获取一个brokerName与lastBrokerName不相等的队列，即不会再次选择上次发送失败的broker如果没有找到一个不同broker的mq，那么退回到轮询的方式；</p>
<p><strong>selectOneMessageQueue</strong>方法选择mq的时候的故障转移机制，其目的就是为了保证每次发送消息尽量更快的成功，是一种保证高可用的手段。总的来说，包括两种故障转移：</p>
<p><strong>1、</strong><br>一种是延迟时间的故障转移，这需要将sendLatencyFaultEnable属性中设置为true，默认false对于请求响应较慢的broker，可以在一段时间内将其状态置为不可用，消息队列选择时，会过滤掉mq认为不可用的broker，以此来避免不断向宕机的broker发送消息，选取一个延迟较短的broker，实现消息发送高可用；<br><strong>2、</strong> 另一种是没有开启延迟时间的故障转移的时候，在轮询选择mq的时候，不会选择上次发送失败的broker，实现消息发送高可用；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQFaultStrategy的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 选择一个消息队列，支持故障延迟转移</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tpInfo         topic信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastBrokerName 上次使用过的broker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 判断是否开启了发送延迟故障转移机制，默认false不打开</span></span><br><span class="line"><span class="comment">     * 如果开启了该机制，那么每次选取topic下对应的queue时，会基于之前执行的耗时，在有存在符合条件的broker的前提下，优选选取一个延迟较短的broker，否则再考虑随机选取。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//当前线程线程的消息队列的下标，循环选择消息队列使用+1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> tpInfo.getSendWhichQueue().incrementAndGet();</span><br><span class="line">            <span class="comment">//遍历消息队列，采用取模的方式获取一个队列，即轮询的方式</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//取模</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//获取该消息队列</span></span><br><span class="line">                <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//如果当前消息队列是可用的，即无故障，那么直接返回该mq</span></span><br><span class="line">                <span class="comment">//如果该broker不存在LatencyFaultTolerance维护的faultItemTable集合属性中，或者当前时间已经大于该broker下一次开始可用的时间点，表示无故障</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName()))</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有选出无故障的mq，那么一个不是最好的broker集合中随机选择一个</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">notBestBroker</span> <span class="operator">=</span> latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="comment">//如果写队列数大于0，那么选择该broker</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">writeQueueNums</span> <span class="operator">=</span> tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//遍历消息队列，采用取模的方式获取一个队列，即轮询的方式</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//重置其brokerName，queueId，进行消息发送</span></span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().incrementAndGet() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//如果写队列数小于0，那么移除该broker</span></span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            log.error(<span class="string">&quot;Error occurred when selecting message queue&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上面的步骤抛出了异常，那么遍历消息队列，采用取模的方式获取一个队列，即轮询的方式</span></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有发送延迟故障转移机制，那么那么遍历消息队列，即采用取模轮询的方式</span></span><br><span class="line">    <span class="comment">//获取一个brokerName与lastBrokerName不相等的队列，即不会再次选择上次发送失败的broker</span></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-selectOneMessageQueue选择一个mq"><a href="#2-5-1-selectOneMessageQueue选择一个mq" class="headerlink" title="2.5.1 selectOneMessageQueue选择一个mq"></a>2.5.1 selectOneMessageQueue选择一个mq</h4><p>selectOneMessageQueue方法有两个重载方法，一个是有参数的，另一个是无参数的。<br>无参数的方法，即轮询选择一个mq，没有任何限制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicPublishInfo的方法</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 轮询的选择一个mq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">()</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取下一个index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.sendWhichQueue.incrementAndGet();</span><br><span class="line">    <span class="comment">//取模计算索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index) % <span class="built_in">this</span>.messageQueueList.size();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取该索引的mq</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.messageQueueList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有参数的方法，其参数是上一次发送失败的brokerName，并且在选择的时候，不会选择上一次发送失败的brokerName的mq，即避免选择发送失败的broker继续发送。当然如果最后没有选出来，那么还是走轮询获取的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TopicPublishInfo的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lastBrokerName 上一次发送失败的brokerName</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> MessageQueue <span class="title function_">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果lastBrokerName为null，即第一次发送，那么轮询选择一个</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//轮询选择一个mq</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.sendWhichQueue.incrementAndGet();</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> Math.abs(index) % <span class="built_in">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="built_in">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="comment">//如果mq的brokerName不等于lastBrokerName，就返回，否则选择下一个</span></span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有选出来，那么轮询选择一个</span></span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-sendKernelImpl发送消息"><a href="#2-6-sendKernelImpl发送消息" class="headerlink" title="2.6 sendKernelImpl发送消息"></a>2.6 sendKernelImpl发送消息</h3><p>选择了消息队列之后，会调用sendKernelImpl方法进行消息的发送。该方法的大概步骤为：</p>
<p><strong>1、</strong><br>首先调用findBrokerAddressInPublish方法从brokerAddrTable中查找Masterbroker地址如果找不到，那么再次调用tryToFindTopicPublishInfo方法从nameServer远程拉取配置，并更新本地缓存，随后再次尝试获取Masterbroker地址；<br><strong>2、</strong> 调用brokerVIPChannel判断是否开启vip通道，如果开启了，那么将brokerAddr的port–2，因为vip通道的端口为普通端口–2；<br><strong>3、</strong> 如果不是批量消息，那么设置唯一的uniqId；<br><strong>4、</strong> 如果不是批量消息，并且消息体大于4K，那么进行消息压缩；<br><strong>5、</strong> 如果存在CheckForbiddenHook，则执行checkForbidden钩子方法如果存在SendMessageHook，则执行sendMessageBefore钩子方法；<br><strong>6、</strong> 设置请求头信息SendMessageRequestHeader，请求头包含各种基本属性，例如producerGroup、topic、queueId等，并且针对重试消息的处理，将消息重试次数和最大重试次数存入请求头中；</p>
<ol start="7">
<li>根据不同的发送模式发送消息。如果是异步发送模式，则需要先克隆并还原消息。最终异步、单向、同步模式都是调用MQClientAPIImpl#sendMessage方法发送消息的。</li>
<li>如果MQClientAPIImpl#sendMessage方法正常发送或者抛出RemotingException、MQBrokerException、InterruptedException异常，那么会判断如果存在SendMessageHook，则执行sendMessageAfter钩子方法。</li>
</ol>
<p><strong>9、</strong> 在finally块中，对原始消息进行恢复；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> * 发送消息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg               消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq                mq</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> communicationMode 发送模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sendCallback      发送回调</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topicPublishInfo  topic信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout           超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 发送结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> SendResult <span class="title function_">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> MessageQueue mq,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> CommunicationMode communicationMode,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> SendCallback sendCallback,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> <span class="type">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginStartTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1 根据brokerName从brokerAddrTable中查找broker地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">brokerAddr</span> <span class="operator">=</span> <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="comment">//如果本地找不到 broker 的地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == brokerAddr) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2 从nameServer远程拉取配置，并更新本地缓存</span></span><br><span class="line"><span class="comment">         * 该方法此前就学习过了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        <span class="comment">//再次获取地址</span></span><br><span class="line">        brokerAddr = <span class="built_in">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">SendMessageContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (brokerAddr != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 3 vip通道判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="built_in">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 4 如果不是批量消息，那么尝试生成唯一uniqId，即UNIQ_KEY属性。MessageBatch批量消息在生成时就已经设置uniqId</span></span><br><span class="line"><span class="comment">             * uniqId也被称为客户端生成的msgId，从逻辑上代表唯一一条消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 设置nameSpace为实例Id</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">topicWithNamespace</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != <span class="built_in">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                msg.setInstanceId(<span class="built_in">this</span>.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">                topicWithNamespace = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息标识符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sysFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//消息压缩标识</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">msgBodyCompressed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 5 尝试压缩消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                msgBodyCompressed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//事务消息标志，prepare消息</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">tranMsg</span> <span class="operator">=</span> msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">            <span class="keyword">if</span> (Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 6 如果存在CheckForbiddenHook，则执行checkForbidden方法</span></span><br><span class="line"><span class="comment">             * 为什么叫禁止钩子呢，可能是想要使用者将不可发送消息的检查放在这个钩子函数里面吧（猜测）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="type">CheckForbiddenContext</span> <span class="variable">checkForbiddenContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckForbiddenContext</span>();</span><br><span class="line">                checkForbiddenContext.setNameSrvAddr(<span class="built_in">this</span>.defaultMQProducer.getNamesrvAddr());</span><br><span class="line">                checkForbiddenContext.setGroup(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                checkForbiddenContext.setCommunicationMode(communicationMode);</span><br><span class="line">                checkForbiddenContext.setBrokerAddr(brokerAddr);</span><br><span class="line">                checkForbiddenContext.setMessage(msg);</span><br><span class="line">                checkForbiddenContext.setMq(mq);</span><br><span class="line">                checkForbiddenContext.setUnitMode(<span class="built_in">this</span>.isUnitMode());</span><br><span class="line">                <span class="built_in">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 7 如果存在SendMessageHook，则执行sendMessageBefore方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                context = <span class="keyword">new</span> <span class="title class_">SendMessageContext</span>();</span><br><span class="line">                context.setProducer(<span class="built_in">this</span>);</span><br><span class="line">                context.setProducerGroup(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                context.setCommunicationMode(communicationMode);</span><br><span class="line">                context.setBornHost(<span class="built_in">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">                context.setBrokerAddr(brokerAddr);</span><br><span class="line">                context.setMessage(msg);</span><br><span class="line">                context.setMq(mq);</span><br><span class="line">                context.setNamespace(<span class="built_in">this</span>.defaultMQProducer.getNamespace());</span><br><span class="line">                <span class="type">String</span> <span class="variable">isTrans</span> <span class="operator">=</span> msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                <span class="keyword">if</span> (isTrans != <span class="literal">null</span> &amp;&amp; isTrans.equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">&quot;__STARTDELIVERTIME&quot;</span>) != <span class="literal">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 8 设置请求头信息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">SendMessageRequestHeader</span> <span class="variable">requestHeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMessageRequestHeader</span>();</span><br><span class="line">            requestHeader.setProducerGroup(<span class="built_in">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">            requestHeader.setTopic(msg.getTopic());</span><br><span class="line">            requestHeader.setDefaultTopic(<span class="built_in">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">            requestHeader.setDefaultTopicQueueNums(<span class="built_in">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">            requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">            requestHeader.setSysFlag(sysFlag);</span><br><span class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">            requestHeader.setFlag(msg.getFlag());</span><br><span class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">            requestHeader.setUnitMode(<span class="built_in">this</span>.isUnitMode());</span><br><span class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">            <span class="comment">//针对重试消息的处理</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//获取消息重新消费次数属性值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">reconsumeTimes</span> <span class="operator">=</span> MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//将重新消费次数设置到请求头中，并且清除该属性</span></span><br><span class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取消息的最大重试次数属性值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">maxReconsumeTimes</span> <span class="operator">=</span> MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//将最大重新消费次数设置到请求头中，并且清除该属性</span></span><br><span class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 9 根据不同的发送模式，发送消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 异步发送模式</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 首先克隆并还原消息</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 该方法的finally中已经有还原消息的代码了，为什么在异步发送消息之前，还要先还原消息呢？</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 因为异步发送时 finally 重新赋值的时机并不确定，有很大概率是在第一次发送结束前就完成了 finally 中的赋值，</span></span><br><span class="line"><span class="comment">                     * 因此在内部重试前 msg.body 大概率已经被重新赋值过，而 onExceptionImpl 中的重试逻辑 MQClientAPIImpl.sendMessageAsync 不会再对数据进行压缩，</span></span><br><span class="line"><span class="comment">                     * 简言之，在异步发送的情况下，如果调用 onExceptionImpl 内部的重试，有很大概率发送的是无压缩的数据</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">Message</span> <span class="variable">tmpMessage</span> <span class="operator">=</span> msg;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">messageCloned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//如果开启了消息压缩</span></span><br><span class="line">                    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">                        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">                        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">                        <span class="comment">//克隆一个message</span></span><br><span class="line">                        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                        messageCloned = <span class="literal">true</span>;</span><br><span class="line">                        <span class="comment">//恢复原来的消息体</span></span><br><span class="line">                        msg.setBody(prevBody);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果topic整合了namespace</span></span><br><span class="line">                    <span class="keyword">if</span> (topicWithNamespace) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">if</span> (!messageCloned) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                            messageCloned = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//还原topic</span></span><br><span class="line">                        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="built_in">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 发送消息之前，进行超时检查，如果已经超时了那么取消本次发送操作，抛出异常</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">costTimeAsync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 10 发送异步消息</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                            brokerAddr,</span><br><span class="line">                            mq.getBrokerName(),</span><br><span class="line">                            tmpMessage,</span><br><span class="line">                            requestHeader,</span><br><span class="line">                            timeout - costTimeAsync,</span><br><span class="line">                            communicationMode,</span><br><span class="line">                            sendCallback,</span><br><span class="line">                            topicPublishInfo,</span><br><span class="line">                            <span class="built_in">this</span>.mQClientFactory,</span><br><span class="line">                            <span class="built_in">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                            context,</span><br><span class="line">                            <span class="built_in">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 单向、同步发送模式</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 发送消息之前，进行超时检查，如果已经超时了那么取消本次发送操作，抛出异常</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">costTimeSync</span> <span class="operator">=</span> System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemotingTooMuchRequestException</span>(<span class="string">&quot;sendKernelImpl call timeout&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 10 发送单向、同步消息</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    sendResult = <span class="built_in">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                            brokerAddr,</span><br><span class="line">                            mq.getBrokerName(),</span><br><span class="line">                            msg,</span><br><span class="line">                            requestHeader,</span><br><span class="line">                            timeout - costTimeSync,</span><br><span class="line">                            communicationMode,</span><br><span class="line">                            context,</span><br><span class="line">                            <span class="built_in">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 9 如果存在SendMessageHook，则执行sendMessageAfter方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                context.setSendResult(sendResult);</span><br><span class="line">                <span class="built_in">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回执行结果</span></span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果抛出了异常，如果存在SendMessageHook，则执行sendMessageAfter方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                context.setException(e);</span><br><span class="line">                <span class="built_in">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                context.setException(e);</span><br><span class="line">                <span class="built_in">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                context.setException(e);</span><br><span class="line">                <span class="built_in">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 对消息进行恢复</span></span><br><span class="line"><span class="comment">             * 1、因为客户端可能还需要查看原始的消息内容，如果是压缩消息，则无法查看</span></span><br><span class="line"><span class="comment">             * 2、另外如果第一次压缩后消息还是大于4k，如果不恢复消息，那么客户端使用该message重新发送的时候，还会进行一次消息压缩</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            msg.setBody(prevBody);</span><br><span class="line">            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), <span class="built_in">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The broker[&quot;</span> + mq.getBrokerName() + <span class="string">&quot;] not exist&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-1-findBrokerAddressInPublish查找broker地址"><a href="#2-6-1-findBrokerAddressInPublish查找broker地址" class="headerlink" title="2.6.1 findBrokerAddressInPublish查找broker地址"></a>2.6.1 findBrokerAddressInPublish查找broker地址</h4><p>首先会根据brokerName从brokerAddrTable中查找broker地址。生产者只会向Master节点发送消息，因此只会返回Master节点的地址。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQClientInstance的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findBrokerAddressInPublish</span><span class="params">(<span class="keyword">final</span> String brokerName)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//查询brokerAddrTable缓存的数据</span></span><br><span class="line">    HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* address */</span>&gt; map = <span class="built_in">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">    <span class="comment">//返回Mater节点的地址</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span> &amp;&amp; !map.isEmpty()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> map.get(MixAll.MASTER_ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-brokerVIPChannel判断vip通道"><a href="#2-6-2-brokerVIPChannel判断vip通道" class="headerlink" title="2.6.2 brokerVIPChannel判断vip通道"></a>2.6.2 brokerVIPChannel判断vip通道</h4><p>**获取到brokerAddr之后，需要判断是否开启vip通道，如果开启了，那么将brokerAddr的port – 2，因为vip通道的端口为普通通道端口– 2。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MixAll的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">brokerVIPChannel</span><span class="params">(<span class="keyword">final</span> <span class="type">boolean</span> isChange, <span class="keyword">final</span> String brokerAddr)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果开启了vip通道</span></span><br><span class="line">    <span class="keyword">if</span> (isChange) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="type">int</span> <span class="variable">split</span> <span class="operator">=</span> brokerAddr.lastIndexOf(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> brokerAddr.substring(<span class="number">0</span>, split);</span><br><span class="line">        <span class="type">String</span> <span class="variable">port</span> <span class="operator">=</span> brokerAddr.substring(split + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//重新拼接brokerAddr，其中port - 2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">brokerAddrNew</span> <span class="operator">=</span> ip + <span class="string">&quot;:&quot;</span> + (Integer.parseInt(port) - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> brokerAddrNew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//如果没有开启vip通道，那么返回原地址</span></span><br><span class="line">        <span class="keyword">return</span> brokerAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者拉取消息只能请求普通通道，但是生产者发送消息可以选择vip通道或者普通通道。</p>
<p><a href="https://github.com/apache/rocketmq/issues/1510">为什么要开启两个端口监听客户端请求呢</a><br>？答案是隔离读写操作。在消息的API中，最重要的是发送消息，需要高RTT。如果普通端口的请求繁忙，会使得netty的IO线程阻塞，例如消息堆积的时候，消费消息的请求会填满IO线程池，导致写操作被阻塞。在这种情况下，我们可以向VIP频道发送消息，以保证发送消息的RTT。</p>
<p>但是，请注意，在rocketmq<br>4.5.1版本之后，客户端发送消息的请求选择VIP通道的配置被改为false，想要手动默认开启需要配置com.rocketmq.sendMessageWithVIPChannel属性。或者在创建producer的时候调用producer.setVipChannelEnabled()<br>方法更改当前producer的配置。</p>
<p><img src="https://gitee.com/fadeway32/fadeway32/raw/master/img/202502162034497.png" alt="*"><br><strong>因此，现在发送消息和消费消息实际上默认都走10911端口了，无需再关心10909端口的问题了。</strong></p>
<h4 id="2-6-3-setUniqID生成uniqId"><a href="#2-6-3-setUniqID生成uniqId" class="headerlink" title="2.6.3 setUniqID生成uniqId"></a>2.6.3 setUniqID生成uniqId</h4><p>该方法用于设置单条消息在客户端的uniqId，即设置到UNIQ_KEY属性中，批量消息在生成时就已经设置uniqId。</p>
<p>uniqId也被称为msgId，从逻辑上代表客户端生成的唯一一条消息，更多见此<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43767015/article/details/121751053">文章</a>，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21561501/article/details/105684989">uniqId生成规则</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MessageClientIDSetter的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setUniqID</span><span class="params">(<span class="keyword">final</span> Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果这条消息不存在&quot;UNIQ_KEY&quot;属性，那么创建uniqId并且存入&quot;UNIQ_KEY&quot;属性中</span></span><br><span class="line">    <span class="keyword">if</span> (msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX) == <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        msg.putProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, createUniqID());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-tryToCompressMessage压缩消息"><a href="#2-6-4-tryToCompressMessage压缩消息" class="headerlink" title="2.6.4 tryToCompressMessage压缩消息"></a>2.6.4 tryToCompressMessage压缩消息</h4><p>在发送单条消息的时候，会判断如果消息体超过4K，那么会进行消息压缩，压缩比默认为5，压缩完毕之后设置压缩标志，批量消息不支持压缩。消息压缩有利于更快的进行网络数据传输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryToCompressMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果是批量消息，那么不进行压缩</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> MessageBatch) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//batch dose not support compressing right now</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] body = msg.getBody();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//如果消息长度大于4K</span></span><br><span class="line">        <span class="keyword">if</span> (body.length &gt;= <span class="built_in">this</span>.defaultMQProducer.getCompressMsgBodyOverHowmuch()) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                <span class="comment">//进行压缩，使用的JDK自带的压缩类</span></span><br><span class="line">                <span class="type">byte</span>[] data = UtilAll.compress(body, zipCompressLevel);</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                    <span class="comment">//重新设置到body中</span></span><br><span class="line">                    msg.setBody(data);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">                log.error(<span class="string">&quot;tryToCompressMessage exception&quot;</span>, e);</span><br><span class="line">                log.warn(msg.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-updateFaultItem更新故障表"><a href="#2-7-updateFaultItem更新故障表" class="headerlink" title="2.7 updateFaultItem更新故障表"></a>2.7 updateFaultItem更新故障表</h3><p>再发送消息完毕之后，无论是正常还是异常状态，都需要调用updateFaultItem方法，更新本地错误表缓存数据，用于延迟时间的故障转移的功能。</p>
<p>故障转移功能在此前的selectOneMessageQueue方法中被使用到，用于查找一个可用的消息队列。updateFaultItem方法在判断开启了故障转移之后，会更新LatencyFaultTolerance维护的faultItemTable集合属性中的异常broker数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultMQProducerImpl的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> brokerName brokerName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentLatency 当前延迟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isolation 是否使用默认隔离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="type">boolean</span> isolation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//调用MQFaultStrategy#updateFaultItem方法</span></span><br><span class="line">    <span class="built_in">this</span>.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看<strong>MQFaultStrategy#updateFaultItem</strong><br>方法。其根据本次发送消息的延迟时间currentLatency，会去计算出该broker的隔离时间duration，即可以计算出该broker的下一个可用时间点。然后更新故障记录表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQFaultStrategy的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> brokerName     brokerName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentLatency 当前延迟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isolation      是否使用默认隔离时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="type">boolean</span> isolation)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果开启了故障转移，即sendLatencyFaultEnable为true，默认false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//根据消息当前延迟currentLatency计算当前broker的故障延迟的时间duration</span></span><br><span class="line">        <span class="comment">//如果isolation为true，则使用默认隔离时间30000，即30s</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="comment">//更新故障记录表</span></span><br><span class="line">        <span class="built_in">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-1-computeNotAvailableDuration计算隔离时间"><a href="#2-7-1-computeNotAvailableDuration计算隔离时间" class="headerlink" title="2.7.1 computeNotAvailableDuration计算隔离时间"></a>2.7.1 computeNotAvailableDuration计算隔离时间</h4><p>computeNotAvailableDuration方法根据本次发送消息的延迟时间currentLatency，会去计算出该broker的隔离时间duration，或者说不可以用时间段，据此即可以计算出该broker的下一个可用时间点。</p>
<p>latencyMax延迟等级和notAvailableDuration隔离时间的对应关系如下：</p>
<table>
<thead>
<tr>
<th align="left"><strong>latencyMax，Producer发送消息消耗时长</strong></th>
<th align="left"><strong>notAvailableDuration，Broker不可用时长</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>50L</strong></td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left"><strong>100L</strong></td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left"><strong>550L</strong></td>
<td align="left">30000L</td>
</tr>
<tr>
<td align="left"><strong>1000L</strong></td>
<td align="left">60000L</td>
</tr>
<tr>
<td align="left"><strong>2000L</strong></td>
<td align="left">120000L</td>
</tr>
<tr>
<td align="left"><strong>3000L</strong></td>
<td align="left">180000L</td>
</tr>
<tr>
<td align="left"><strong>15000L</strong></td>
<td align="left">600000L</td>
</tr>
</tbody></table>
<p>**如果使用默认隔离时间30000，那个实际将会被隔离600000L，即10分钟。当抛出异常的时候，通常会设置isolation，即使用默认隔离时间。并且从这个表可以看出来，发送消息延迟越大，那么被设置的隔离时间也就越大。<br>**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟等级</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[] latencyMax = &#123;</span><br><span class="line">   </span><br><span class="line">     <span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"><span class="comment">//不可用时间等级</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span>[] notAvailableDuration = &#123;</span><br><span class="line">   </span><br><span class="line">     <span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MQFaultStrategy的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentLatency 当前延迟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 故障延迟的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> currentLatency)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//倒叙遍历latencyMax</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//选择broker延迟时间对应的broker不可用时间，默认30000对应的故障延迟的时间为600000，即10分钟</span></span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-2-updateFaultItem更新故障表"><a href="#2-7-2-updateFaultItem更新故障表" class="headerlink" title="2.7.2 updateFaultItem更新故障表"></a>2.7.2 updateFaultItem更新故障表</h4><p>该方法更新LatencyFaultToleranceImpl维护的faultItemTable集合属性中的异常broker的故障信息，将会设置发送消息的延迟时间currentLatency属性，以及下一个可用时间点LatencyFaultToleranceImpl属性。</p>
<p>下次可用时间LatencyFaultToleranceImpl属性&#x3D; 现在的时间 +<br>隔离的时间，在selectOneMessageQueue方法选取消息队列的时候，如果开启了集群故障转移，那么会查找下一个可用时间点小于当前时间点的broker的队列来发送消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LatencyFaultToleranceImpl的方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name                 brokerName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentLatency       当前延迟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> notAvailableDuration 隔离时间（不可用时间）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="type">long</span> currentLatency, <span class="keyword">final</span> <span class="type">long</span> notAvailableDuration)</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//获取该broker此前的故障记录数据</span></span><br><span class="line">    <span class="type">FaultItem</span> <span class="variable">old</span> <span class="operator">=</span> <span class="built_in">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="comment">//如果此前没有数据，那么设置一个新对象肌凝乳</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == old) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">final</span> <span class="type">FaultItem</span> <span class="variable">faultItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FaultItem</span>(name);</span><br><span class="line">        <span class="comment">//设置当前延迟</span></span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        <span class="comment">//设置下一次可用时间点</span></span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        <span class="comment">//已有故障记录，更新</span></span><br><span class="line">        old = <span class="built_in">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//已有故障记录，更新</span></span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>本次我们学习了Producer的发送消息的源码总体流程，对于具体的发送消息的sendMessage方法源码将在下文讲解。</p>
<p>从这些源码中，我们得知了一些常见的却容易混淆的概念和知识，例如：</p>
<p><strong>1、</strong> 生产者消息重试：RocketMQ的消费者消息重试和生产者消息重投；<br><strong>2、</strong> 生产者故障转移通过sendLatencyFaultEnable属性配置是否开启，默认未开启故障转移机制，其目的就是为了保证每次发送消息尽量更快的成功，是一种保证高可用的手段总的来说，包括两种故障转移：；</p>
<p><strong>1、</strong><br>一种是延迟时间的故障转移，这需要将sendLatencyFaultEnable属性中设置为true，默认false对于请求响应较慢的broker，可以在一段时间内将其状态置为不可用，消息队列选择时，会过滤掉mq认为不可用的broker，以此来避免不断向宕机的broker发送消息，选取一个延迟较短的broker，实现消息发送高可用；<br><strong>2、</strong> 另一种是没有开启延迟时间的故障转移的时候，在轮询选择mq的时候，不会选择上次发送失败的broker，实现消息发送高可用；<br><strong>3、</strong> Vip通道VIP通道用于隔离读写操作消费者拉取消息只能请求普通通道，但是生产者发送消息可以选择vip通道或者普通通道；</p>
<p><strong>1、</strong><br>在消息的API中，最重要的是发送消息，需要高RTT如果普通端口的请求繁忙，会使得netty的IO线程阻塞，例如消息堆积的时候，消费消息的请求会填满IO线程池，导致写操作被阻塞在这种情况下，我们可以向VIP频道发送消息，以保证发送消息的RTT；<br><strong>2、</strong><br>但是，请注意，在rocketmq4.5.1版本之后，客户端发送消息的请求选择VIP通道的配置被改为false，想要手动默认开启需要配置com.rocketmq.sendMessageWithVIPChannel属性或者在创建producer的时候调用producer.setVipChannelEnabled()<br>方法更改当前producer的配置；<br><strong>4、</strong><br>故障转移表，RocketMQ的Producer生产者故障转移依赖于故障转移表实现，他是一个HasmMap消息发送结束之后，会根据本次发送消息的延迟时间currentLatency，会去计算出该broker对应的的隔离时间duration，即可以计算出该broker的下一个可用时间点，然后更新故障记录表故障转移表的key为brokerName，value为未来该broker可用时间；</p>

                
                <p class="end">__END__</p>
            </div>
            <div class="article-footer">
                <div class="suffix-box">
    <div class="suffix-box-left">
        <img src="/image/sidebar/avatar.jpg" alt="Live For Code">
    </div>
    <div class="suffix-box-right">
        <span class="suffix-box-title">文章作者：</span>Live For Code
        <br>
        <span class="suffix-box-title">文章出处：</span><a href="/article/1739713332/" target="_blank">07、RocketMQ源码分析：Producer发送消息的总体流程【一万字】</a>
        <br>
        <span class="suffix-box-title">作者签名：</span>你知道的越多,你不知道的越多
        <br>
        <span class="suffix-box-title">关于主题：</span><a href="https://fadeway32.gitee.io/" target="_blank">fadeway32</a>
        <br>
        <span class="suffix-box-title">版权声明：</span>文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
        <br>
    </div>
    <div style="clear: both;"></div>
</div>
                
                    <div class="category">
                        分类：
                        
                            <a href="/category/Web/">Web</a>
                        
                    </div>
                
                
                    <div class="tag">
                        标签：
                        
                            <a href="/tag/RocketMq/">RocketMq</a>
                        
                    </div>
                
                <div class="article-prev-next">
                    
                        <a href="/article/1739713334/" class="prev-prefix">« </a> 上一篇：    <a href="/article/1739713334/" title="发布于 2025-02-16 09:42">09、RocketMQ源码分析：Broker接收消息入口源码</a>
                        <br>
                    
                    
                        <a href="/article/1739713335/" class="next-prefix">» </a> 下一篇：    <a href="/article/1739713335/" title="发布于 2025-02-16 09:42">10、RocketMQ源码分析：BrokerasyncSendMessage处理消息以及自动创建Topic</a>
                    
                </div>
            </div>
            
    <div class="article-comments">
        
            <div class="comments-title">
                评论列表
            </div>
        
        <div class="comments-content"></div>
    </div>

        </div>
    
</div>
    <div id="footer"></div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        
            <div class="menu-notice">
                <span class="iconfont icon-notice"></span>
                <div class="notice">
                    <span>简单地活着，肆意而又精彩！</span>
                </div>
            </div>
        
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar">
                    <img src="/image/sidebar/avatar.jpg">
                </div> 
                <div class="introduce-info"> 
                    <div class="introduce-user"><span>Live For Code</span></div>
                </div> 
            </div> 
            <div class="menu-list">
                <ul>
                    
                        <li class=""><a href="/" class="" target="_self"><span class="iconfont icon-home-fill"></span>首页</a></li>
                    
                        <li class=""><a href="/category" class="" target="_self"><span class="iconfont icon-folder-fill"></span>分类</a></li>
                    
                        <li class=""><a href="/tag" class="" target="_self"><span class="iconfont icon-discount-fill"></span>标签</a></li>
                    
                        <li class=""><a href="/archive" class="" target="_self"><span class="iconfont icon-calendar-fill"></span>归档</a></li>
                    
                        <li class=""><a href="/donate" class="" target="_self"><span class="iconfont icon-heart-fill"></span>赞赏</a></li>
                    
                        <li class=""><a href="/about" class="" target="_self"><span class="iconfont icon-about-fill"></span>关于</a></li>
                    
                        <li class=""><a href="/atom.xml" class="" target="_blank"><span class="iconfont icon-rss"></span>订阅</a></li>
                    
                        <li class=""><a href="javascript:;" class="search" target="_self"><span class="iconfont icon-search-menu"></span>搜索</a></li>
                    
                        <li class=""><a href="/comment" class="" target="_self"><span class="iconfont icon-comments-fill"></span>留言板</a></li>
                    
                        <li class=""><a href="/friend" class="" target="_self"><span class="iconfont icon-link"></span>友情链接</a></li>
                    
                </ul> 
            </div> 
            <div class="menu-link">
                <div class="box">
                    <div class="image-box"></div>
                </div>
                
                    <a name="知乎" href="https://www.zhihu.com/people/wo-xin-de-love" class="" target="_blank" data=""><span class="iconfont icon-zhihu"></span></a>
                
                    <a name="微博" href="https://weibo.com/u/3939432776" class="" target="_blank" data=""><span class="iconfont icon-weibo"></span></a>
                
                    <a name="QQ" href="javascript:;" class="image" target="_self" data="https://gitee.com/fadeway32/fadeway32/raw/master/img/B5C4BECA9D2E1BBE5B5B9020421E9426.png"><span class="iconfont icon-qq"></span></a>
                
                    <a name="微信" href="javascript:;" class="image" target="_self" data="https://gitee.com/fadeway32/fadeway32/raw/master/img/F35AB4B62DEAE3B5DC2907087E35424E.png"><span class="iconfont icon-wechat"></span></a>
                
                    <a name="GitHub" href="https://github.com/first19326" class="" target="_blank" data=""><span class="iconfont icon-github"></span></a>
                
            </div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="/css/search.css">
<script type="text/javascript" src="/js/iscroll.js"></script>
<script type="text/javascript" src="/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>

    
        <link type="text/css" rel="stylesheet" href="/css/APlayer.css">
        <script type="text/javascript" src="/js/APlayer.min.js"></script>
        <script type="text/javascript" src="/js/Meting.min.js"></script>
        <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>
    
    
    <div class="wrap-right">
        <div class="setting">
            <div class="iconbox favorites" switch="false">
                <span class="iconfont icon-favorites"></span>
                <span class="icontext">关注</span>
            </div>
            <div class="iconbox mode">
                <div class="light">
                    <span class="iconfont icon-daymode"></span>
                    <span class="icontext">浅色模式</span>
                </div>
                <div class="dark">
                    <span class="iconfont icon-nightmode-fill"></span>
                    <span class="icontext">深色模式</span>
                </div>
            </div>
            <a href="javascript:;" target="_self" class="search">
                <div class="iconbox">
                    <span class="iconfont icon-search-menu"></span>
                    <span class="icontext">搜索</span>
                </div>
            </a>
            <div class="iconbox bottom">
                <div style="display: inline-block; transform: rotate(180deg);">
                    <span class="iconfont icon-top"></span>
                </div>
                <span class="icontext">跳至底部</span>
            </div>
        </div>
        <div class="iconbox set">
            <div style="display: inline-block;">
                <span class="iconfont icon-setting"></span>
            </div>
            <span class="icontext">设置</span>
        </div>
        <div class="iconbox top">
            <span class="iconfont icon-top"></span>
            <span class="icontext">返回顶部</span>
        </div>
    </div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : "first19326",
        GitHubRepositories : "Hexo-LiveForCode",

        User             : "Live For Code",
        UserAvatar       : "/image/sidebar/avatar.jpg",
        WebsiteStartDate : "2020-01-01",

        WebsiteTitleBlur         : "(◍´꒳`◍) Hi, Live For Code",
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : "(*´∇｀*) 欢迎回来!",
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : "/image/website/logo.png",

        ProgressBar : {
            id       : "topProgressBar",
            color    : "#77B6FF",
            height   : "2px",
            duration : 0.2
        },

        Loading: {
            rebound : {
                tension  : 16,
                friction : 5
            },
            spinner : {
                id     : "spinner",
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : "#F0F0F0",
                    stroke     : "#272633",
                    base       : "",
                    child      : "#272633"
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : "rgba(255, 255, 255, .2)",
            clearOffset : 0.3
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : "60%",
            colorBrightness  : "50%",
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : "random",
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                "/image/header/home.jpg",
            
                "/image/header/home.jpeg",
            
                "/image/header/2023-04-17-20-51-03.jpg",
            
                "/image/header/2023-04-17-20-54-07.jpg",
            
                "/image/header/2023-04-17-20-54-22.jpg",
            
                "/image/header/2023-04-17-20-55-25.jpg",
            
                "/image/header/2023-04-17-21-04-19.jpg",
            
                "/image/header/2023-04-17-21-04-34.jpg",
            
                "/image/header/2023-04-17-21-04-41.jpg",
            
                "/image/header/2023-04-17-21-05-22.jpg",
            
        ],
        HomeBannerText  : "",

        ArticleHeaderImage : [
            
                "/image/header/article.jpg",
            
                "/image/header/2023-04-17-21-04-19.jpg",
            
                "/image/header/2023-04-17-21-04-34.jpg",
            
                "/image/header/2023-04-17-21-04-41.jpg",
            
                "/image/header/2023-04-17-21-05-22.jpg",
            
        ],

        OtherBannerText : "",

        Error : {
            icon    : "icon-swimming",
            title   : "PAGE NOT FOUND",
            content : [
                
                    "很抱歉，您访问的页面不存在！",
                
                    "可能是输入地址有误或该地址已变更。",
                
            ],
            buttons : [
                
                    {
                        icon  : "icon-home",
                        text  : "返回首页",
                        href  : "https://fadeway32.gitee.io/",
                        class : ""
                    },
                
            ]
        },

        MenuNotice : {
            enable : true,
            notice : "简单地活着，肆意而又精彩！",
            speed  : 20
        },
        MenuList : [
            
                {
                    name   : "首页",
                    icon   : "icon-home-fill",
                    href   : "/",
                    type   : "index",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "分类",
                    icon   : "icon-folder-fill",
                    href   : "/category",
                    type   : "category",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "标签",
                    icon   : "icon-discount-fill",
                    href   : "/tag",
                    type   : "tag",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "归档",
                    icon   : "icon-calendar-fill",
                    href   : "/archive",
                    type   : "archive",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "赞赏",
                    icon   : "icon-heart-fill",
                    href   : "/donate",
                    type   : "donate",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "关于",
                    icon   : "icon-about-fill",
                    href   : "/about",
                    type   : "about",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "订阅",
                    icon   : "icon-rss",
                    href   : "/atom.xml",
                    type   : "",
                    class  : "",
                    target : "_blank"
                },
            
                {
                    name   : "搜索",
                    icon   : "icon-search-menu",
                    href   : "javascript:;",
                    type   : "",
                    class  : "search",
                    target : "_self"
                },
            
                {
                    name   : "留言板",
                    icon   : "icon-comments-fill",
                    href   : "/comment",
                    type   : "comment",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "友情链接",
                    icon   : "icon-link",
                    href   : "/friend",
                    type   : "friend",
                    class  : "",
                    target : "_self"
                },
            
        ],
        MenuLink : [
            
                
                    {
                        name   : "知乎",
                        icon   : "icon-zhihu",
                        href   : "https://www.zhihu.com/people/wo-xin-de-love",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "微博",
                        icon   : "icon-weibo",
                        href   : "https://weibo.com/u/3939432776",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "QQ",
                        icon   : "icon-qq",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "https://gitee.com/fadeway32/fadeway32/raw/master/img/B5C4BECA9D2E1BBE5B5B9020421E9426.png"
                    },
                
                    {
                        name   : "微信",
                        icon   : "icon-wechat",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "https://gitee.com/fadeway32/fadeway32/raw/master/img/F35AB4B62DEAE3B5DC2907087E35424E.png"
                    },
                
                    {
                        name   : "GitHub",
                        icon   : "icon-github",
                        href   : "https://github.com/first19326",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
            
        ],

        FooterStyle : 2,
        BottomText  : "<div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2022 WorstOne. All Rights Reserved.</div>",

        ConsoleList : [
            
                
                    [
                        
                            
                                "Based on cnblogs theme SimpleMemory.",
                            
                                "",
                            
                        
                    ],
                
                    [
                        
                            
                                "SimpleMemory Author:",
                            
                                "BNDong",
                            
                        
                    ],
                
                    [
                        
                            
                                "Theme:",
                            
                                "LiveForCode",
                            
                        
                    ],
                
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : "",
            bitcoin : "",
            alipay  : "/image/donate/alipay.png",
            wechat  : "/image/donate/wechat.png"
        },

        Search : {
            applicationID : "758UIQ1V0H",
            apiKey        : "2e038c318ac6813e4b4baa91f6ccfa63",
            indexName     : "hexo2",
            hits          : {
                page : 30
            },
            labels        : {
                placeholder : "搜索",
                empty       : "未发现与 「${query}」 相关的内容",
                stats       : "${hits} 条相关条目，使用了 ${time} 毫秒",
            }
        }, 

        Valine : {
            switch         : true,
            el             : ".comments-content",
            appId          : "srhKtvWPQTWYKh3qX8G8M7v0-gzGzoHsz",
            appKey         : "8uVSP1q6UlALVC5igYfIfv2h",
            serverURLs     : "",
            placeholder    : "你是我一生只会遇见一次的惊喜...",
            avatar         : "mm",
            meta           : "nick,mail,link",
            requiredFields : "nick,mail",
            pageSize       : 5,
            lang           : "zh-cn",
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : ".toc",
            contentSelector       : ".article-body",
            headingSelector       : "h1, h2, h3, h4, h5",
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : ".toc",
            positionFixedClass    : "toc-fixed",
            fixedSidebarOffset    : "",
        },

        Require : {
            baseUrl     : "/js/",
            waitSeconds : 100
        },

        Music : {
            type : "Meting"
        },
        APlayer : {
            container : ".aplayer",
            fixed     : true,
            autoplay  : true,
            loop      : "all",
            order     : "random",
            preload   : "auto",
            volume    : 0.67,
            mutex     : true,
            lrcType   : 2,
            audio     : [
                
                    {
                        name   : "Endless Tears",
                        artist : "CLIFF EDGE",
                        cover  : "/music/cover/Endless Tears.jpg",
                        url    : "/music/song/Endless Tears.mp3",
                        lrc    : "/music/lrc/Endless Tears.lrc"
                    },
                
            ]
        },
        Meting : {
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        Mouse : {
            enable  : true,
            options : {
                size  : 6,
                sizeF : 24
            }
        },

        LazyLoad : {
            default : "/image/website/lazyload.svg"
        },
  
        Style : {
            aplayer          : "/css/APlayer.css",
            archive          : "/css/archive.css",
            base             : "/css/base.css",
            clipboard        : "/css/clipboard.css",
            code             : "/css/code.css",
            donate           : "/css/donate.css",
            fancybox         : "/css/jquery.fancybox.css",
            footer           : "/css/footer.css",
            iconfont         : "/iconfont/iconfont.css",
            index            : "/css/index.css",
            menuBubble       : "/css/menu-bubble.css",
            mouse            : "/css/mouse.css",
            page             : "/css/page.css",
            post             : "/css/post.css",
            search           : "/css/search.css",
            tocbot           : "/css/tocbot.css",
            valine           : "/css/valine.css"
        },

        Script: {
            aplayer          : "/js/APlayer.min.js",
            config           : "/js/require.config.js",
            index            : "/js/index.js",
            instantSearch    : "/js/instantsearch.min.js",
            iscroll          : "/js/iscroll.js",
            jQuery           : "/js/jquery-3.4.1.min.js",
            loading          : "/js/loading.js",
            meting           : "/js/Meting.min.js",
            require          : "/js/require.min.js"
        },

        Font: {
            LongCang    : "/font/LongCang.css",
            Monda       : "/font/Monda.css",
            NotoSansSC  : "/font/NotoSansSC.css",
            NotoSerifSC : "/font/NotoSerifSC.css",
            Playball    : "/font/Playball.css",
            PTMono      : "/font/PTMono.css",
            Roboto      : "/font/Roboto.css",
            RobotoSlab  : "/font/RobotoSlab.css",
            Rosario     : "/font/Rosario.css",
            UbuntuMono  : "/font/UbuntuMono.css"
        },

        Suffix : {
            about : "你知道的越多,你不知道的越多"
        },
            
        Theme : {
            url  : "https://fadeway32.gitee.io/",
            name : "fadeway32"
        }  
    };
</script>
    <script type="text/javascript" src="/js/index.js"></script>
</body>
</html>